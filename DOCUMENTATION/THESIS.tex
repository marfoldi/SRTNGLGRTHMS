\documentclass{elteikthesis}

\usepackage{url}
\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{ucs}
\usepackage{xcolor}
\usepackage{float}
\usepackage{afterpage}
\usepackage[utf8]{inputenc}
\usepackage[nottoc,numbib]{tocbibind}
\usepackage[T1]{fontenc}
\usepackage[english,hungarian]{babel}
\selectlanguage{hungarian}

\title{Rendezési algoritmusok szemléltetése}
\author{Márföldi Péter Bence}
\supervisor{Veszprémi Anna}
\supervisorstitle{mestertanár}
\period{programtervező informatikus BSc}
\thesisyear{2015}
\department{Algoritmusok és Alkalmazásaik Tanszék}

\fancyhf{}
\fancyhead[L]{\rightmark}
\fancyfoot[C]{\thepage}
\definecolor{default}{HTML}{F3622D}
\definecolor{swap}{HTML}{4258C9}
\definecolor{select}{HTML}{57B757}
\definecolor{done}{HTML}{8C2D46}
\setcounter{tocdepth}{4}
\newcommand{\hiddensubsubsection}[1]{
	\stepcounter{subsubsection}
	\subsubsection*{{#1}}	
}
\newcommand{\hiddenparagraph}[1]{
	\stepcounter{paragraph}
	\paragraph*{{#1}}
}

\begin{document}

\frontmatter

	\maketitle
	\renewcommand{\thepage}{}
	\tableofcontents
	
\mainmatter
	\pagestyle{fancy}
	\setlist[description]{leftmargin=\parindent,labelindent=\parindent,itemsep=1.5pt}

\chapter{Bevezetés} 
 Az eddigi egyetemen töltött éveim során az \textbf{Algoritmusok és adatszerkezetek} kurzus foglalkozott mélyrehatóan a rendezési algoritmusokkal. Számomra a tananyagból talán ez a témakör volt a legnehezebben elsajátítható. Ez sarkallt arra, hogy a szakdolgozatom témáját adják ezek az eljárások, szerettem volna biztos tudással rendelkezni ezen a területen.\par
 Az bizonyos, hogy minden informatikus - beleértve a leendőeket is - tanulmányaik kezdetén találkoztak ezen eljárásokkal. Nagyszerű terület arra, hogy megérthessük mi a műveletigény, hogy mi számít igazán sok adatnak, vagy, hogy mit értünk egy algoritmus stabilitásán.\par

\section{A feladat és annak értelmezése}
A feladat egy oktatóprogram létrehozása, melynek segítségével az érdeklődő megértheti néhány rendezési algoritmus működését egy egyszerű, letisztult felületen. Lehetőséget kell adni az algoritmusok lépésenkénti vizsgálatára, továbbá a műveletek számának összehasonlítására. A felhasználó több módon megadhatja a rendezendő pozitív egész számokat:
\begin{description}
	\item[$\bullet$] begépeléssel
	\item[$\bullet$] generálással
	\item[$\bullet$] fájlból betöltéssel
\end{description}\par
A bemutatott algoritmusok lépéseit, valamint a rendezendő értékeket minél szemléletesebben kell megjeleníteni. Így nem elegendő csak a számok egymás utáni kiíratása az egyes lépésekben.

\section{Alkalmazott technológiák}
A Következőkben röviden összefoglaljuk a \emph{Java}\cite{Java}, \emph{JavaFX}\cite{JavaFX} és \emph{JUnit}\cite{JUnit} jellegzetességeit.
\subsection{Java}
A \emph{Java} egy általános célú, objektumorientált programozási nyelv, melyet 2009-ig a \emph{Sun Microsystems} fejlesztett, ezt követően pedig az \emph{Oracle}. A szakdolgozatban használt 1.8-as verziót már az \emph{Oracle} adta ki 2014-ben. A \emph{Java} nyelv a szintaxisát a \emph{C} és \emph{C++} nyelvektől örökölte, azonban utóbbitól eltérően egyszerű objektummodellel rendelkezik. \par
 A \emph{Java} platformra készült programok túlnyomó többsége asztali alkalmazás. Manapság egyre több helyen találkozhatunk a \emph{Java} nyelven írt programokkal, például mobil eszközökön, banki rendszereknél vagy akár egy szórakoztató elektronikai eszközön. Nagy előnye, hogy sok nyelvvel ellentétben platformfüggetlen, azaz egy adott platformról egy program minimális változtatással átültethető egy másik platformra. \par
 A \emph{Java} legfontosabb része a \emph{Java virtuális gép (JVM)}. A \emph{JVM}-et sokféle berendezés és szoftvercsomag tartalmazza, így a nyelv egyaránt platformként és középszintként is működik.
Összefoglalva a \emph{Java} program három fontos szerepet tölt be:
\begin{description}
\item[$\bullet$] programozási nyelv
\item[$\bullet$] köztes réteg (middleware)
\item[$\bullet$] platform
\end{description}

\subsection{JavaFX}
Olyan szoftverplatform, amelynek célja, hogy gazdag internetes alkalmazást lehessen készíteni és futtatni eszközök széles skáláján. Eredetileg a \emph{Swing} könyvtárat váltotta volna fel, azonban jelenleg mindkettő része a \emph{Jave SE}-nek. \par
 A 2.0-ás verzióig a fejlesztők egy külön nyelvet használtak, amelyet \emph{JavaFX Script}-nek neveznek. Azonban mivel ez szintén \emph{Java} bájtkódot generál a későbbiekben megadatott a lehetőség, hogy a programozók Java kódot használjanak helyette. A \emph{JavaFX} egyik legnagyobb előnye, hogy egy egyszerű \emph{XML} struktúrában leírhatók a program grafikus felületének összetevői, melyhez ezt követően elegendő az egyes interakciókhoz tartozó funkciókat implementálni.\par Az elterjedtebb operációs rendszerek mindegyikét támogatja. Ahogyan előnye, úgy hátránya is a \emph{Swing}-hez képest az, hogy jelenleg is folyik a fejlesztése, ezért olykor csak hosszas utánajárást követően sikerül megoldást találni egy-egy problémára.
 
\subsection{JUnit}
Egy egységteszt keretrendszer a \emph{Java} programozási nyelvhez. Az egységtesztek karbantartására, és futtatására kínál szolgáltatást. Gyakran a verzió kiadási folyamat részeként szokták beépíteni, azaz egy kiadás akkor hibátlan, ha ezen tesztek mindegyike hibátlanul lefut. Egy 2013-as felmérésben\cite{Survey} tízezer Java technológiát használó \emph{GitHub} projektet vizsgáltak. A projektek csaknem harmadánál használták a \emph{JUnit}-ot, ezzel az egyik leggyakrabban használt függvénykönyvtár volt a felmérésben résztvevő projektekben.

\chapter{Felhasználói dokumentáció}
\section{Rendszerkövetelmények}
Az elkövetkezőkben ismertetésre kerülnek a minimális és az ajánlott rendszerkövetelmények.
\subsection{Minimális rendszerkövetelmények}
Mivel a program \emph{Java} nyelven íródott, ezért elengedhetetlen, hogy a felhasználó számítógépén lehetőség legyen \emph{Java} alkalmazások futtatására. Az alábbi operációs rendszereken érhető el a \emph{Java Runtime Enviroment 8u45}-ös verziója:\par
\begin{description}
	\item[$\bullet$] \emph{Windows} 8
	\item[$\bullet$] \emph{Windows} 7
	\item[$\bullet$] \emph{Windows} Vista SP2
	\item[$\bullet$] \emph{Windows Server} 2008 R2 SP1 (64-bit)
	\item[$\bullet$] \emph{Windows Server} 2012 (64-bit)
	\item[$\bullet$] \emph{Mac OS X} 10.8.3 vagy újabb
	\item[$\bullet$] \emph{Suse Linux Enterprise Server} 10 SP2+, 11.x
	\item[$\bullet$] \emph{Ubuntu Linux} 12.04 vagy újabb
	\item[$\bullet$] \emph{Red Hat Enterprise Linux} 5.5+, 6.x
	\item[$\bullet$] \emph{Oracle Linux} 5.5+; 6.x; 7.x
\end{description}
\par Hardverkövetelmények tekintetében a \emph{Java JRE 8} futtatásához szükséges
minimum követelményei az irányadóak. Azonban a program bizonyos esetekben több erőforrást is igényelhet, ezért ajánlott nagyobb memóriával és erősebb processzor rendelkező rendszer használata. A követelmények a következő táblázatban találhatóak:\par
\begin{table}[h]
		\def\arraystretch{2}
		\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Memória}           & 128 MB            \\ \hline
		\textbf{Szabad lemezterület} & 124 (+2) MB       \\ \hline
		\textbf{Processzor}          & \emph{Pentium} 2 266 MHz \\ \hline
	\end{tabular}
\end{table}
\subsection{Ajánlott rendszerkövetelmények}
A szoftver tökéletes működéséhez a legelterjedtebb operációs rendszer, a \emph{Windows} ajánlott. Továbbá követelmény 16:9-es képaránnyal rendelkező monitor, és legalább 1366$\times$768 képernyőfelbontás használata.\par
A rendszer fejlesztése a következő ajánlott konfiguráción történt:
\begin{table}[h]
	\def\arraystretch{2}
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Operációs rendszer} & \emph{Windows} 7                     \\ \hline
		\textbf{Memória}            & 4 GB                          \\ \hline
		\textbf{Processzor}         & \emph{Intel} Core i5-2467M, 2000 MHz \\ \hline
	\end{tabular}
\end{table}

\subsection{Telepítés és eltávolítás}
Alapvetően elegendő a \emph{Java} futtatási környezet telepítéséről gondoskodnia a felhasználónak, ezen felül más program telepítésére nincs szükség. Azonban, mivel elsősorban \emph{Windows} operációs rendszeren történő futtatásra lett felkészítve a program, ezt az operációs rendszert használók választhatják a kényelmesebb, natív telepítéses megoldást.\par
Elsőként a programhoz készült telepítővel történő konfigurálást vesszük végig, majd ezt követően a \emph{Java} programokra inkább jellemzőbb, ám kissé körülményesebb telepítési mód kerül bemutatásra. Végül röviden összefoglaljuk a program eltávolításához szükséges lépéseket.
\par Bármely módszert is szándékozik követni a felhasználó, először győződjön meg róla, hogy az előzőekben ismertetett rendszerkövetelményeknek megfelel a számítógépe.

\subsubsection{Telepítés natív telepítővel}
Ez a telepítési mód csak a \emph{Windows}-t használók számára érhető el.\par
Az első lépés a telepítési varázsló elindítása. A megjelenő párbeszédpanelon kattintsunk a \textbf{Telepítés} gombra. Ezt követően elindul a telepítés, ami körülbelül fél percet vesz igénybe.\par
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{pics/setup.png}
	\caption{A telepítési párbeszédpanel}
\end{figure}
A telepítési panel bezárása után máris megjelenik a program főmenüje, így megkezdheti a felhasználó a használatát. A későbbiekben történő futtatáshoz a következő könyvtárba szükséges navigálni: \textbf{C:\textbackslash Felhasználók\textbackslash \{Felhasználói név\}\textbackslash AppData\\ \textbackslash Local\textbackslash SRTNGLGRTHMS\textbackslash SRTNGLGRTHMS.exe} \par
A fenti útvonal akkor érvényes, ha \textbf{C:\textbackslash} meghajtón található az operációs rendszer, néhány rendszeren más lehet ennek a meghajtónak a betűjele. Továbbá egyes számítógépeken az \textbf{AppData} mappa rejtett lehet, így érdemes valamilyen fájlböngészőt, például \emph{Total Commander}-t használni.

\subsubsection{Hagyományos telepítés}
A most ismertetésre kerülő telepítési mód minden operációs rendszeren elérhető.\par
Az első feladat a \emph{Java} virtuális gép telepítése, amely letölthető a következő webcímről: \url{http://java.com/inc/BrowserRedirect1.jsp}\par
Fogadjuk el a licencszerződést, töltsük le a \emph{JRE} telepítőfájlt. Ha frissíteni szeretnénk a jelenlegi \emph{Java} verziót a rendszerünkön, akkor előbb célszerűbb eltávolítani a régi verziót. Miután feltelepítettük a futtatási környezetet,  készen áll a szoftver futtatására a rendszerünk. A program könyvtárában található \textbf{SRTNGLGRTHMS.jar} fájl elindításával kezdhetjük meg a szoftver használatát.

\subsubsection{Eltávolítás}
A program törlése az utóbb ismertetett telepítési mód esetében mindössze annyiból áll, hogy a \textbf{SRTNGLGRTHMS.jar} fájlt eltávolítjuk, valamint amennyiben a jövőben nincs igény a \emph{Java} futtatási környezet használatára, úgy a felhasználó eltávolíthatja azt.\par
\emph{Windows}-on történő natív telepítést követően a program telepítési könyvtárában található \textbf{unins000.exe} fájlt futtatva, majd az \textbf{Igen} gombra kattintva a program törlődik a számítógépről.

\section{Felhasználói felület bemutatása}
\subsection{Főmenü}
A program indítását követően megjelenik a főmenü, mely két komponensből áll.\par
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/mainmenu.png}
	\caption{A program főmenüje}
\end{figure}
  Az ablak felső részén található piros színnel jelölt rész az eszköztárat foglalja magában. A kék szín jelöli a főmenü központi paneljét, mely három gombból tevődik össze. Ezen gombokra történő kattintás után lehetőség nyílik a rendezendő számok megadására.

\subsubsection{Eszköztár}
Az eszköztárat két menüpont alkotja, \textbf{Fájl} és \textbf{Segítség} címszóval ellátva. Az előzőben a program bezárásának lehetősége kapott helyet, míg utóbbiban a szoftver névjegye tekinthető meg. Az \textbf{Ok} gomb lenyomásával bezárható a névjegy.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.5\textwidth]{pics/about.png}
	\caption{A program névjegye}
\end{figure}

\subsubsection{Központi panel}
A három gombból áll:
\begin{description}
	\item[$\bullet$] Manuális (számok begépelése)
	\item[$\bullet$] Generálás (számok generálása) 
	\item[$\bullet$] Fájl (számok beolvasása)
\end{description}
Ezek közül bármelyre kattintva átnavigálhatunk a bement megadását lehetővé tévő felületekre.

\subsection{Bemenet megadása panel}
Az előzőekben említett három lehetőség közül választhat a felhasználó.

\subsubsection{Manuális}
A megjelenő panelen két gomb található, melyek kezdetben inaktívak. A "Méret:" címke után található beviteli mezőbe egy pozitív egész szám megadásával és az \textbf{ENTER} billentyű leütésével megjelennek a számok bevitelére lehetőséget adó mezők. Ezt követően a panelen található két gomb már kattintható, a \textbf{Számok generálása} gombra kattintva 0 és 100 közötti véletlen számokkal töltődnek fel a mezők. Az \textbf{Ok}ra történő kattintás után megjelenik a program \textbf{Főpanel}je.\par
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{pics/manualinput.png}
	\caption{8 elemű manuálisan megadott bemenet}
\end{figure}
Meg kell jegyezni, hogy ebben a módban legfeljebb száz érték adható meg, ennél nagyobb méretű bemenet manuális feltöltése túl körülményes lenne. Amennyiben több számot szándékozik megadni a felhasználó, válasszon a számok generálása vagy a fájlból történő beolvasás lehetőségek közül.

\subsubsection{Generálás}
A "Méret:" címke mellett megadva a bemeneti számok mennyiségét, és a legördülő menüből kiválasztva a generálás módját az \textbf{OK} gomb kattinthatóvá válik.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{pics/randominput.png}
	\caption{Egymillió véletlen generált érték megadása}
\end{figure}
 A legördülő menüből a következő négy típus közül lehet választani, azaz a generált tömb legyen:
\begin{description}
	\item[$\bullet$] Véletlen generált - véletlenszerűen választott számokból álljon
	\item[$\bullet$] Majdnem rendezett - a tömb 80\%-a már rendezve legyen
	\item[$\bullet$] Fordított - a tömb legyen csökkenőleg rendezett
	\item[$\bullet$] Néhány egyedi - a tömb elemei között sok azonos érték szerepeljen
\end{description}
\par Itt megjegyzendő, hogy amennyiben az input mérete az [1,100] intervallumban van, akkor a rendezendő számok a 0 és 100 közötti értékek közül kerülnek kiválasztásra és megjelenik a \textbf{Megfigyelés} panel. Ennek oka, hogy a túl nagy differencia az egyes értékek között sokat rontana az oszlopdiagramok megjelenésén. Ellenkező esetben a \emph{Java} nyelv által definiált egész típus(\emph{Integer}) maximális értékéig terjedhet a generált számok nagysága és csak a \textbf{Összehasonlítás} panel érhető el.
 
\subsubsection{Fájlból beolvasás}
A gombra történő kattintás után megjelenik egy fájltallózó. A tallózóban csak szöveges(\emph{txt} kiterjesztésű) fájl választására van lehetőség.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{pics/fileinput.png}
	\caption{Fájltallózó}
\end{figure}
 A fájl tartalmára történő megszorítások szigorúak. Minden sora legfeljebb egy pozitív egész számot tartalmazhat, ellenkező esetben a program hibaüzenet kíséretében visszatér a főmenübe. Fontos, hogy az előzőek értelmében az üres sorok sem megengedettek.
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.6\textwidth]{pics/fileinput_error.png}
 	\caption{Nem megfelelő fájl esetén a hibaüzenet}
 \end{figure}

\subsection{Főpanel}
A rendezendő számok sikeres megadása után megjelenik a program főpanelje, mely három logikai részből áll. A főpanel magában foglalja a \textbf{Megfigyelés} és \textbf{Összehasonlítás} paneleket, melyek összetettségükből fakadóan külön alfejezetekben kerülnek részletezésre.
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.8\textwidth]{pics/mainpanel.png}
 	\caption{A program főpanelja}
 \end{figure}
\subsubsection{Eszköztár}
A \textbf{Főmenü}höz hasonlóan itt is jelen van a piros színnel jelzett eszköztár sáv. Itt fontos kiemelni, hogy a \textbf{Fájl} és \textbf{Segítség} pontokon belül további alpontok is elérhetőek:\par
A \textbf{Fájl} menüpont bővül a \textbf{Vissza a főmenübe} lehetőséggel, melynek segítségével a program újraindítása nélkül lehetőség van újabb rendezendő számsorozat megadására.\par
A \textbf{Segítség}re kattintva további lehetőségként választható \textbf{Az algoritmusról} pont. Itt elolvasható a rövid szöveges ismertetője a \textbf{Megfigyelés} panel listájából kiválasztott elemnek. Amennyiben pedig az \textbf{Összehasonlítás} panel aktív, akkor e panel táblázatából kiválasztott algoritmus leírása tekinthető meg. Az aktuális panelen ha nem került kiválasztásra sor, akkor a menüpontra történő kattintás után felugró ablak figyelmezteti a felhasználót arról, hogy e menüpont használatához előbb ki kell választani egy algoritmust.
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.5\textwidth]{pics/algorithm_error.png}
 	\caption{Nincs kiválasztott algoritmus hibaüzenet}
 \end{figure}
\subsubsection{Panelválasztó}
Amennyiben a bemenet megadásánál már ismertetett [1,100] intervallum magában foglalja a bemenet hosszát, akkor két elem látható a zöld jelölt részen. Így lehetősége van a felhasználónak navigálni a \textbf{Megfigyelés} és az \textbf{Összehasonlítás} panel között. Ellenkező esetben csak az utóbbi panel jelenik meg. Az aktuálisan megjelenített felület neve a listában kék kerettel jelenik meg, valamint a másik elemhez képest világosabb szürke színnel.
\subsubsection{Panel}
A harmadik logikai egységet alkotják a panelek - kék színnel jelölve -, melyek közötti váltást a \textbf{Panelválasztó} teszi lehetővé. Mivel részletesebb leírást kíván a panelek ismertetése, ezért egy-egy külön alfejezetben kerülnek bemutatásra.

\subsection{Megfigyelés panel}
A főpanel középső területén foglal helyet, négy komponensből tevődik össze. A felhasználónak itt nyílik lehetősége az egyes algoritmusok megfigyelésére, tanulmányozására.
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.8\textwidth]{pics/watchpanel.png}
 	\caption{Megfigyelés panel}
 \end{figure}
\subsubsection{Algoritmus lista}
Az ábrán piros színnel jelölt rész, melynek elemeire kattintva kiválasztható, hogy mely algoritmust szeretné a felhasználó vizsgálni. A kiválasztott elem kék háttérszínt kap, alapértelmezett esetben nincs kijelölt elem.
\subsubsection{Állapotjelző táblázat}
A kiválasztott algoritmus aktuális állapotához tartozó információk jelennek meg a táblázatban. Az ábrán zöld kerettel van jelölve a komponens. Amennyiben nincs kiválasztott elem a \textbf{Nincs megjeleníthető adat} szöveg jelenik meg.\par
Két oszlopa a \textbf{Tulajdonság} és a \textbf{\#}, mely utóbbi az értéket jelöli. Alapvetően az összehasonlításon alapuló algoritmusoknál megjelenő adatok az összehasonlítások és cserék vagy mozgatások száma. Az edényrendezéseknél pedig az aktuálisan vizsgált bit indexe és a vizsgálatok száma jelenik meg. Egyes algoritmusokhoz a jobb megérhetőség miatt további állapotjelző értékek is tartoznak, melyek a következők:
\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|}
		\hline
		\textbf{Algoritmus} & \textbf{Tulajdonság} \\ \hline
		Shell rendezés      & Lépésköz             \\ \hline
		Gyorsrendezés       & Vezérelem            \\ \hline
		Radix "előre"       & Cserék száma         \\ \hline
	\end{tabular}
\end{table}
\subsubsection{Gombok}
Alaphelyzetben a \textbf{Léptetés} és \textbf{Lejátszás} gombok inaktívak. A képen fekete keretet jelzi a helyüket. Amennyiben a felhasználó kiválaszt egy elemet az algoritmus listáról kattinthatóvá vállnak. A léptetéssel egy következő állapotot tekinthet meg a felhasználó. A \textbf{Lejátszás} gombra kattintva a program bemutatja az algoritmus működését. A felhasználó bármikor megállíthatja az animációt a \textbf{Lejátszás} gomb helyén található \textbf{Megállítás} gombra kattintva, majd ha kívánja innen folytathatja a vizsgálatot. Amennyiben a rendezés lezajlott, megjelenik az \textbf{Újraindítás} gomb, melynek megnyomásával az értékek visszakerülnek az eredeti helyükre.

\subsubsection{Állapotjelző felület}
A fenti ábrán kék szín jelöli ezt a területet.
Az állapotjelző felületen minden esetben legalább egy oszlopdiagram foglal helyet. Ettől eltérően a \textbf{Kupac}- és \textbf{Versenyrendezés} kiválasztásakor egy gráf is helyet kap. Továbbá a \textbf{Radix "vissza"} rendezés második tömbjének reprezentálásához egy plusz oszlopdiagram is megjelenik. Itt megjegyzendő, hogy a szemléltetéshez használt bináris fa legfeljebb 31 csúcsot tartalmazhat. Hosszabb bemenet megadásakor csak az első 31 elem vesz részt a megjelenítésben, erről felugró ablak tájékoztatja a felhasználót:
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.8\textwidth]{pics/splittedinput.jpg}
 	\caption{Megváltozott bemenetről a figyelmeztetőablakok}
 \end{figure}

\par Az egyes műveleteket különböző színek is jelölik. Alapértelmezetten a rendezendő elemek színe a következőket jelentik:\par
\begin{description}
	\item[\textcolor{default}{\Huge$\bullet$}] Az alapértelmezett szín, nincs kijelölve az elem.
	\item[\textcolor{swap}{\Huge$\bullet$}] Az elem cserére vagy mozgatásra van kijelölve.
	\item[\textcolor{select}{\Huge$\bullet$}] Az elemnek kitüntetett szerepe van.
	\item[\textcolor{done}{\Huge$\bullet$}] Az elem már a végleges helyére került.
\end{description}
A \textcolor{select}{\Huge$\bullet$} jelölés némi magyarázatra szorul. A kitüntetett szerepű elemnek számít például a gyorsrendezés vezéreleme, vagy a versenyrendezés fájának felépítésekor egy belső csúcsba kerülő elem.\par
Némely algoritmusnál a fentiektől eltérő lehet az egyes színek jelentése. A következő fejezetben(2.3), az algoritmusok ismertetésénél jelölve van minden ilyesfajta különbség.

\subsection{Összehasonlítás panel}
A \textbf{Megfigyelés panel}lel megegyezően a főpanel középső részén található, két logikai egységből épül fel. Lehetőséged ad az összehasonlításon alapuló rendezések műveletigényeinek a vizsgálására.
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=0.8\textwidth]{pics/benchmarkpanel.png}
 	\caption{Összehasonlítás panel}
 \end{figure}
\subsubsection{Elemzés táblázat}
Piros kerettel jelölt rész az ábrán, mely táblázatnak négy oszlopa van:
\begin{description}
	\item[$\bullet$] Név - az algoritmus neve
	\item[$\bullet$] Hasonlítások - a rendezés során végzett összehasonlítások szummája
	\item[$\bullet$] Mozgatások - az elemmozgatások számának összege
	\item[$\bullet$] Cserék - a végzett cserék szummája
\end{description}
A \textbf{Mozgatások} oszlop minden esetben kitöltésre kerül, még ha az algoritmus nem is mozgatásokat használ. Ekkor a mozgatások oszlopban a cserék számának háromszorosa jelenik meg. Ennél fogva egyszerűbb az algoritmusok vizsgálata.
\subsubsection{Elemzés diagram}
A táblázathoz képest balra helyezkedik el a zöld kerettel jelölt oszlopdiagram. Kezdetben teljesen üres, csak a jelölések jelentése látható. Az \textbf{Elemzés táblázat} egy során történő dupla kattintás következtében megjelenik az algoritmus összehasonlításainak és mozgatásainak a száma. Előbbi narancs- utóbbi citromsárga színnel. Amennyiben olyan sorra kattint a felhasználó, mely már látható a diagramon, azon algoritmus adatai eltűnnek a felületről.

\section{A vizsgált algoritmusok}
\subsection{Buborékrendezés}
\hiddensubsubsection{Leírás}
A legrégebbi és a legegyszerűbb rendezési algoritmus. Mindemellett a legtöbb esetben a leglassabb is. Már az 1965-ös évben megjelent egy teljes körű elemzése\cite{Demuth}.
\hiddensubsubsection{Működés}
 A rendezés minden egyes elemet összehasonlít a rákövetkező elemmel, és ha szükséges megcseréli őket. Ez azt eredményezi, hogy lépésenként a maximális elem "buborék" szerűen a lista végére kerül, ezzel egyidejűleg a kisebb elemek "lesüllyednek" a tömb elejére. Amennyiben egy menetben a maximális eleme elérte a helyét visszavezetjük a problémát az eggyel "rövidebb" rendezési feladatra\cite{Fekete}. Az algoritmus javítható azzal, ha figyeljük, hogy az egyes menetekben történt-e csere. Amennyiben egy olyan menet végére értünk, amelyben egy elem helye sem változott, akkor a tömb már rendezve van. A program az eredeti, nem javított verziót mutatja be.
 \hiddensubsubsection{Példa}
 A rendezendő számok: $42, 22, 10, 57$.\par
 Az első ábrán szerepel a kezdeti állapot, a másodikon az első két értéket cseréje látható. A 42 ismét fentebb kerül egy pozícióval a harmadik ábrán. A negyedik ábrán csupán egy összehasonlítás történik, mivel az 57 nagyobb mint az őt megelőző érték. Az ötödik ábrán az előző állapot első két értékének(22 és 10) a cseréje látható. Az ezt követő összehasonlítás eredménye, hogy a második legnagyobb érték(42) a helyére került. Ezt követően már csak egy összehasonlítást történik, mely után az adatsor rendezve lesz.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/bubble.jpg}
 	\caption{Példa a buborékrendezésre}
 \end{figure}
 \hiddensubsubsection{Műveletigény}
Párosával haladunk végig az elemeken, és így vizsgáljuk őket. Mivel minden menet végén visszavezetjük a problémát az eggyel rövidebb feladatra, ezért az összehasonlítások száma $n$ hosszú bemenetre:\par
$$\ddot{O}(n)=(n-1)+(n-2)+\ldots+1=\frac{n\cdot(n-1)}{2}=\frac{n^2}{2}-\frac{n}{2}=\Theta(n^2)$$
\par A cserék száma már nem állandó, a bemenő adatok inverziószámával egyezik meg. Belátható, hogy minden egyes cserével egy inverzió szüntethető meg két elem között. A legtöbb cserét akkor szükséges eszközölni, ha a rendezendő elemek mindegyike inverzióban áll a rákövetkező elemmel, azaz a tömb nagyság szerint csökkenő sorrendben rendezett. Ekkor a cserék száma:\par
$$MCs(n)=\frac{n\cdot(n-1)}{2}=\Theta(n^2)$$
Amennyiben a tömb elemei már rendezettek, akkor egyetlen cserét sem szükséges végrehajtani.
Az átlagos csereszám a maximális cserék számának fele\cite{Fekete}, ám nagyságrendileg még ez is $\Theta(n^2)$
\hiddensubsubsection{Jelölések az állapotjelző felületen}
Kitüntetettnek (\textcolor{select}{\Huge$\bullet$} színnel) jelöljük azt az elemet, amely egy csere következtében feljebb került. Nincs egyéb eltérés az eredeti jelölésekhez képest.

\subsection{Beszúró rendezés}
\hiddensubsubsection{Leírás}
 A legtöbb esetben akár kétszer hatékonyabb a buborékrendezéshez képest\cite{Fekete}. Az elve egyszerűen megérthető egy hétköznapi példán keresztül: A kezünkben tartunk kártyalapokat, majd egy pakliból húzva az új lapot beszúrjuk a kezünkben lévő, már rendezett lapok közé. Ennélfogva szokás kártyás rendezésnek is nevezni.
\hiddensubsubsection{Működés}
Két részre bontjuk a tömböt, az egyik részén - a tömb bal széle - a már rendezett, míg a másikon a még nem vizsgált elemek szerepelnek. Kezdetben a tömb első elemét tekintjük a rendezett résznek.\par
Lényege, hogy a soron következő elemet - a második elemtől kezdve - egy ideiglenes változóba mentjük, és a rendezett tömbrész elemeit jobbra csúsztatjuk mindaddig, amíg a kiválasztott érték nem kerül a helyére. Ezt n-1 alkalommal ismételve megkapjuk a rendezett tömböt.
 \hiddensubsubsection{Példa}
 A rendezendő számok megegyeznek a buborékrendezés bemutatásánál használtakkal, azaz: $42, 22, 10, 57$.\par
 Az első ábrán szerepel a kezdeti állapot. A következő képen jelöljük azt, hogy a második elemet fogjuk beszúrni. A harmadik ábrán felcsúsztatjuk a 42 értéket, majd a negyedik képen már látható, hogy a tömb első két eleme alkotja rendezett tömbrészt. Ezt követően a harmadik elem kerül kiválasztásra. Az összehasonlítások eredményeképp a teljes rendezett tömbrészt jobbra tolódik, így az 7. képen már a tömb első három eleme megfelelő sorrendben van. Végül a tömb utolsó eleme kerül összehasonlításra az őt megelőzővel, mivel nagyobb tőle, így kész a rendezési feladat.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/insertion.jpg}
 	\caption{Példa a beszúró rendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
Legjobb esetben elegendő a második elemtől mindegyik elemet az előtte található értékkel összehasonlítani, vagyis a tömb már eleve rendezett\cite{Ronyai}. Ez pontosan n-1 összehasonlítást jelent, azaz:
$$m\ddot{O}(n)=(n-1)=\Theta(n)$$
Ebben az esetben pedig egyetlen elemet sem kell mozgatni.\par
A legrosszabb eset akkor áll fenn, ha a beszúrandó elem minden alkalommal kisebb a már beszúrt elemeknél, azaz a tömb elemei csökkenőleg rendezettek\cite{Fekete}. Ekkor az összehasonlítások száma:
$$M\ddot{O}(n)=\sum\limits_{i=1}^n i = \frac{(1+(n-1))\cdot(n-1)}{2}=\frac{n\cdot(n-1)}{2}=\Theta(n^2)$$
Továbbá ekkor a mozgatások száma:
$$MM(n)=\Theta(n^2)$$
\hiddensubsubsection{Jelölések az állapotjelző felületen}
A már rendezett tömbrészt \textcolor{done}{\Huge$\bullet$} szín jelöli. Az aktuálisan beszúrandó elem pedig a \textcolor{select}{\Huge$\bullet$} jelölést kapja. A kiválasztott elemmel összehasonlított értékek \textcolor{swap}{\Huge$\bullet$} színt kapnak.\par
Megjegyzendő, hogy a kitüntetett szerepű avagy beszúrandó elem nem szerepel tömbelemként az összehasonlításkor, csupán a felületen van jelölve a jobb megérthetőség okán.

\subsection{Shell rendezés}
\hiddensubsubsection{Leírás}
\textbf{Donald Shell} nevéhez fűződik, a legtöbb esetben a leggyorsabb négyzetes idejű algoritmus. Az elve az, hogy célszerű lehet előbb a "távolabb" lévő elemeket hasonlítani és mozgatni, mivel így az elemek hamarabb közel kerülhetnek a végleges helyükhöz.
\hiddensubsubsection{Működés}
Többször vizsgálja a tömböt, és minden alkalommal egy részén beszúró rendezést hajt végre. Arra, hogy mekkora méretű résztömböt vizsgáljon az egyes lépésekben az algoritmus több javaslat is található. A teljesség igénye nélkül néhány ajánlás\cite{ShellWiki} erre vonatkozóan:\par
\begin{table}[h]
	\def\arraystretch{2}
	\centering
	\begin{tabular}{|c|c|c|c|}
		\hline
		\textbf{Szabály (k=1...)} & \textbf{Konkrét értékek}  & \textbf{Műveletigény} & \textbf{Szerző}         \\ \hline
		$\lfloor n / 2^k \rfloor$&      $\left\lfloor\frac{n}{2}\right\rfloor,
		\left\lfloor\frac{n}{4}\right\rfloor, \ldots$, 1            &              $\Theta(n^2)$                      & Shell, 1959     \\ \hline
		$2^k-1$&      1, 3, 7, 11, $\ldots$           &              $\Theta(n^\frac{3}{2})$                      & Hibbard, 1963    \\ \hline
		$2^p 3^q$ váltakozva & 1, 2, 3, 4, $\ldots$  &               $\Theta(n \log^2 n)$                     & Pratt, 1971     \\ \hline
	\end{tabular}
\end{table}
 \hiddensubsubsection{Példa}
 Az előző példákban használt számokat kívánjuk rendezni ismét, azaz a bemenet: $42, 22, 10, 57$.\par
 Az első képen látható a kezdeti állapot. A következő ábrán jelöljük azt, hogy a negyedik elemet fogjuk mozgatni, ekkor a lépésköz három. A harmadik képen már kettő a vizsgált elemek távolsága. A harmadik, kiválasztott elemet beszúrjuk az első elem helyére. A negyedik képen vesszük a következő elemet, továbbra is 2 lépésközzel, ekkor nem szükséges mozgatni. Végül az ötödik megjelenített lépéstől kezdve beszúró rendezést alkalmazunk.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/shell.jpg}
 	\caption{Példa a Shell rendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
 A fentebbi táblázatból látható, hogy az algoritmus sebessége nagyban függ a lépésköz megválasztásától. A program a \textbf{Vaughan Pratt} által javasolt értékeket\cite{Pratt} használja, így legrosszabb esetben $\Theta(n \log^2 n)$ a műveletek száma.\par
 A legjobb eset akkor áll fenn, ha a tömb elemei már rendezettek, ekkor nincs szükség mozgatásra, az algoritmus futási ideje $\Theta(n)$ nagyságrendű.
\hiddensubsubsection{Jelölések az állapotjelző felületen}
 A felület bemutatásában szereplőkhöz képest nincs eltérés.

\subsection{Gyorsrendezés}
\hiddensubsubsection{Leírás}
\textbf{C.A.R. Hoare}\cite{Horae} alkotta meg 1965-ben. Az egyik leggyorsabb rendezési eljárás, ezért rendkívül gyakran alkalmazzák.
\hiddensubsubsection{Működés}
Helyben rendező, oszd meg és uralkodj\cite{Cormen} elven működő rekurzív algoritmus. A következő négy lépésre bontható fel az rendezés:
\begin{description}
	\item[$\bullet$] Ha csak egy vagy nulla elemű az elemzett rész, akkor ne tegyünk semmit.
	\item[$\bullet$] Válasszunk egy vezérelemet (legjobb oldalibb elem).
	\item[$\bullet$] Osszuk két részre a rendezendő részt, mozgassuk a vezérelemtől kisebb elemeket, míg a nagyobbakat a tömb végébe\cite{Ronyai}.
	\item[$\bullet$] Rekurzívan ismételjük meg az előbbi lépéseket a résztömbökön.
\end{description}
Gyakorlatilag szétválasztást eszközölünk, melynek eredményeképp a kiválasztott elemtől kisebb értékek tőle balra, a nagyobbak pedig jobbra helyezkednek el. Az egyszerűbb megérthetőséget szem előtt tartva a program mindig a legjobboldalibb elemet szelektálja.
 \hiddensubsubsection{Példa}
 Az eddigi példákkal megegyezően a bemenet: $42, 22, 10, 57$.\par
 Az első képen látható a már kiválasztott vezérelem. A negyedik ábráig csak összehasonlítások történnek, mivel minden elem kisebb, mint a kiválasztott érték. A negyedik képen a három elemű résztömbön végezzük el a rendezést, a vezérelem ismét a legjobboldalibb érték. Az ötödik képen az első érték nagyobb mint a vezérelem, így ezt az elemet a hatodik képen megcseréljük a vezérelemmel. Ezt követően a középső két elem kerül összehasonlításra, mivel nincs szükség cserére így a rendezés befejeződött.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/quick.jpg}
 	\caption{Példa a gyorsrendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
A rendezés műveletigényét befolyásolja, hogy hogyan választjuk meg a vezérelemet. Például a legrosszabb futási időt ($\Theta(n^2)$) eredményezi, ha mindig a legjobboldalibb elemet választjuk vezérelemnek, és a tömb elemei csökkenő sorrendben vannak\cite{Cormen}. Éppen ezért a gyakorlatban javasolt ezen elem véletlenszerű megválasztása.\par
Ha feltételezzük azt, hogy minden rekurzív lépés felezi a tömböt, akkor egy $n\log(n)$ magasságú fával lehet ábrázolni a rekurziót. Továbbá, mivel minden szinten az elemek száma $n$, és ezek particionálásához használt lépésszám $\Theta(n)$ így a legjobb esetben a futási idő $\Theta(n\cdot\log(n))$.\par
 A gyorsrendezés a legtöbb esetben(közepes és nagy méretű bemenetre) a legmegfelelőbb választás ha számít a rendezés sebessége, mivel az átlagos futási ideje - $\mathcal{O}(n\cdot\log(n))$ - közel áll a legjobb futási időhöz\cite{Cormen}.\par
 Amennyiben a tömb elemei már eleve rendezettek vagy esetleg fordított sorrendben szerepelnek nem hatékony az eljárás.
\hiddensubsubsection{Jelölések az állapotjelző felületen}
A vezérelemet \textcolor{select}{\Huge$\bullet$} szín jelöli. Annak érdekében, hogy jobban átlátható legyen, hogy éppen melyik résztömbön folyik a vizsgálat az éppen nem vizsgált rész haloványabb sárga színnel van jelölve. A többi jelölés a felület bemutatásában leírtaknak megfelelően történik.

\subsection{Kupacrendezés}
\hiddensubsubsection{Leírás}
A módszert \textbf{J. W. J. Williams} és \textbf{R. W. Floyd} javasolták 1964-ben\cite{Ronyai}.
Az $\mathcal{O}(n\log (n))$ algoritmusok közül az egyik leglassabb, azonban előnye a gyorsrendezéssel szemben, hogy nem erőteljesen rekurzív. Ennél fogva jól alkalmazható milliós nagyságrendű bemenetre. Ahogyan a neve is sugallja, a rendezéshez egy kupac adatszerkezetet használ. Az algoritmus ismertetése előtt definiáljuk a kupac fogalmát\cite{Fekete}:
Olyan bináris fa, amelyre a következők teljesülnek:
\begin{description}
	\item[$\bullet$] Kizárólag a levelek szintjén hiányozhat csúcs, azaz "majdnem teljes".
	\item[$\bullet$] A levélszint csúcsai balra tömörítettek.
	\item[$\bullet$] Minden belső csúcs értéke nagyobb vagy egyenlő, mint a gyerekeinek értékei.
\end{description}
A második pont értelmében egyetlen olyan csúcs lehet, amelynek csak egy gyereke van, és az közvetlenül a levélszint felett kell, hogy elhelyezkedjen.\par
\hiddensubsubsection{Működés}
A rendezés az előbbi tulajdonságokra támaszkodik. 
Az algoritmus a bemeneti elemekből kupacot épít, majd a legfelsőbb elemét áthelyezi a kupac "végére". Ezt követően ellenőrzi a kupac tulajdonságokat, ahol szükséges cseréket hajt végre, hogy helyreálljon a kupac adatszerkezet, ekkor már az utolsó, legjobboldalibb levélelem nem vesz részt a kupacépítésben. A gyökérben található elemet a legjobboldalibb levélelem elé helyezi, és újraépíti a kupacot. Ezen lépések addig ismétlődnek, amíg már a maximális elem áthelyezése nem lehetséges, a kupac "végére" helyezési művelet elérte a gyökeret.\par
 \hiddensubsubsection{Példa}
 Az eddigi példákkal azonosan a rendezendő számsorozat: $42, 22, 10, 57$.\par
 Az első kép a kezdeti állapotot mutatja. Ezt követően a bemeneti adatokból kupacot építünk, melynek eredménye a második ábra. A gyökérelemet a levélszint utolsó elemével megcseréljük a harmadik képen. Ellenőrizzük, hogy teljesülnek-e a kupac tulajdonságok, amennyiben nem cseréket hajtunk végre, ennek eredménye látható a 4. képen. Ismét a gyökérelemet lesüllyesztjük, majd ellenőrizzük a kupac tulajdonságot. Az előző két lépést megismételve rendezett tömböt kapunk.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/heap.jpg}
 	\caption{Példa a kupacrendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
A kupacrendezés egyik további, hogy míg a gyorsrendezésnek legrosszabb esetben a futási ideje $\mathcal{O}(n^2)$, addig itt a futási idő továbbra is $\mathcal{O}(n\cdot\log (n))$. Ennél fogva azon rendszereknél, ahol a négyzetes futási idő elfogadhatatlan inkább kupacrendezést alkalmaznak.
\hiddensubsubsection{Jelölések az állapotjelző felületen}
Az éppen összehasonlított értékeket \textcolor{swap}{\Huge$\bullet$} jelöli. Amennyiben csere történt a belső csúcsba kerülő érték háttérszíne \textcolor{select}{\Huge$\bullet$} lesz. Ez alól kivétel, ha a gyökérbe került új érték, mivel ekkor már tudjuk az új legnagyobb értéket, ennek a színe \textcolor{done}{\Huge$\bullet$} lesz. Továbbá akkor is ezt a színt használjuk, ha már a tényleges, végleges helyére került egy elem.

\subsection{Versenyrendezés}
\hiddensubsubsection{Leírás}
A maximum-kiválasztó rendezések közé tartozik, minden egyes menetben kiválasztja a legnagyobb elemet, kiírja és végül eltávolítja. A maximum kiválasztásnak a gyakorlati hátterét a sportesemények lebonyolítási rendje adja, azaz meghatározza az elemek között a "nyertest"\cite{Fekete}. A módszert n=2$^k$ inputhossz esetén érdemes alkalmazni, mivel ettől értérő bemenetre sokkal kedvezőbb eredményt lehet elérni a kupacrendezéssel\cite{Fekete}. \par
\hiddensubsubsection{Működés}
Az algoritmus által használt adatszerkezet egy teljes bináris fa. A bináris fa leveleiben szerepelnek a rendezendő elemek. Az első speciális menetben a fa belső pontjait kitöltjük, úgy, hogy a pontba a gyerekei közüli nagyobb érték kerül.\par 
Ezt követően kerül sor az $(n-1)$ egyszerűbb menetre: A gyökérben található elemet keresve "lefelé" haladunk a bináris fában, majd megtalálva azt a levelet amelyben a gyökér értéke szerepel egy abszolút vesztest állítunk a helyére. Ez az érték a programban -1, mivel csak pozitív egészeket használunk a rendezések szemléltetésére. Ezzel ellentétben a gyakorlatban ez az érték $-\infty$. Majd ezen az "ágon" újrajátsszuk a mérkőzéseket.\par
Amennyiben a bemenet hossza nem kettő hatvány a program -1 értékekkel tölti fel a bináris fa további leveleit, amíg a bemenet hossza nem lesz megfelelő.
 \hiddensubsubsection{Példa}
 Az eddigi példákkal megegyezően a bemenet: $42, 22, 10, 57$.\par
 Az első ábra a kezdőállapotot mutatja. A második kép a versenyfa kitöltését követő állapot, melynek eredményeképp megjelenik az abszolút maximum érték a diagramon. Ezt követően a harmadik képen látható a maximális értékhez tartozó levélelem megtalálásának állapota. A negyedik ábra szemlélteti az újrajátszás eredményét. Az előzőekhez hasonlóan szemléltetik a további képek a maximum érték megjelenítését, a levélelem megkeresését majd az újrajátszás eredményét.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/tournament.jpg}
 	\caption{Példa a versenyrendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
A rendezés egyetlen hátránya a tárigénye, $n$ szám esetén további $n-1$ mezőre szükség van a versenyfa elkészítéséhez. Éppen emiatt a gyakorlatban nem sűrűn használt eljárás. Az első, speciális menet, a versenyfa kitöltése $n-1$ összehasonlítást és mozgatást használ ($n-1$ a belső csúcsok száma). Minden további menetben a fán kétszer kell végigmenni, melynek magassága $\log_2(n)$. Egyszer a maximális levél megtalálásához, majd az újrajátszáshoz, így a ezen menetek $2\log_2(n)$ összehasonlítást végeznek. Mozgatás csak a második, újrajátszási művelethez tartozik. Így a műveletigények:
$$\ddot{O}(n)=n-1+(n-1)\cdot2\cdot\log_2(n)=\Theta(n\cdot(\log(n))$$
$$M(n)=n-1+(n-1)\cdot\log_2(n)=\Theta(n\cdot(\log(n))$$
\hiddensubsubsection{Jelölések az állapotjelző felületen}
Az összehasonlításokat, valamint a maximális levélelem megkereséséhez bejárt utat \textcolor{swap}{\Huge$\bullet$} szín jelöli. A meccsek lejátszásakor a belső csúcsba kerülő érték \textcolor{select}{\Huge$\bullet$} jelölést kap. Ez alól kivétel, amikor a gyökérbe kerül egy meccs győztese, ekkor \textcolor{done}{\Huge$\bullet$} lesz az elem színe, továbbá akkor is ez a jelölés, amikor megtaláltuk a maximális levélcsúcsot.

\subsection{Radix "előre"}
\hiddensubsubsection{Leírás}
Az előzőekben ismertetett algoritmusok mindegyike összehasonlításon alapuló rendezés. A radix rendezés viszont az edényrendezések közé tartozik. Ezen rendezések nem hasonlítják össze az elemeket, hanem az elemek a rendezés során az értéküknek megfelelő edényekbe kerülnek. Az edényrendezések eredményeként rendezett adatsorozatot kapunk lineáris időben\cite{Ronyai}. 
A radix rendezés egy rekurzív algoritmus, melynek minden szintjén létrejönnek az edények.\par
Az általános edényrendezés egy speciális változata a radix előre rendezés, bináris, $d$ hosszú számokra.\par
\hiddensubsubsection{Működés}
Az első menetben a rendezendő elemek első bitjét vizsgálja az algoritmus. A vizsgálat két mutatóval történik, melyek a tömb két végéről indulnak. A tömb elején addig halad a mutató, amíg a vizsgált elem első jegye nem 1, ezzel párhuzamosan a tömb végén olyan elemet keres a másik, melynek első jegye 0. Amennyiben talált ilyen elemeket megcseréli őket. Ezt mindaddig folytatódik, amíg a két mutató nem találkozik. Ekkor kialakul két edény, az elsőben a 0-ás kezdőbittel rendelkező számok, míg a másodikban az 1-essel kezdődő elemek foglalnak helyet. Ezt követően a második bit kerül vizsgálatra az "aledényekben", az előzővel azonos módon. A rendezés befejeződött, ha minden számjegy szerinti vizsgálat megtörtént, vagy ha mindegyik, a futás alatt kialakult edény már csak egy elemet tartalmaz.
 \hiddensubsubsection{Példa}
 Az rendezendő számok: $2, 3, 1, 3$, azaz binárisan $10, 11, 01, 11$.\par
 Az első ábra a kezdőállapotot mutatja. Mivel az első érték valószínűleg nem megfelelő helyen van, ezért a tömb végéről kezdve keresünk egy olyan értéket, amely 0-ás jeggyel kezdődik. A harmadik elem pont ilyen, a második képen ez a két érték cserére van kijelölve, majd a negyedik ábrán megtörténik a két elem cseréje. Az ötödik képen látható a menet során kialakult két edény. Mivel az első edény egy elemű, így nem szükséges a vizsgálata. A második edényben az 10 értéket szeretnénk cserélni, így az edény végétől haladunk előrefelé, amíg nem találunk olyan elemet, melynek második bitje egy. A 11 érték éppen ilyen, ezért megcseréljük őket. Az utolsó ábrán látható a rendezett sorozat.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/radixforward.jpg}
 	\caption{Példa a radix "előre" rendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
A rendezés lineáris időben történik, a számjegyek számát jelölje $d$, ekkor belátható, hogy a legrosszabb esetben is, azaz ha az összes szám minden bitjét meg kell vizsgálnunk az algoritmus futási ideje:
$$T(n)=\Theta(d \cdot n) = \Theta(n)$$
\hiddensubsubsection{Jelölések az állapotjelző felületen}
Az éppen vizsgált elem \textcolor{select}{\Huge$\bullet$} színnel van jelölve. Amennyiben két elemet fel kell cserélni \textcolor{swap}{\Huge$\bullet$} háttérszínt kapnak. Továbbá a már vizsgált elemek háttérszíne fakóbb lesz. Amennyiben egy új edény keletkezik annak a színe véletlenszerűen választódik ki.

\subsection{Radix "vissza"}
\hiddensubsubsection{Leírás}
Az algoritmus rövid ismertetője megegyezik a \textbf{Radix "előre"} rendezés leírásával.
\hiddensubsubsection{Működés}
Az előző algoritmustól eltérően már nem helyben rendez, az eljárásnak két tömbre van szüksége. További különbség, hogy a kisebb helyiértéktől a nagyobb felé halad a vizsgálat.\par Amennyiben az aktuálisan vizsgált bit értéke 0, akkor a "második" tömb elejére, ellenkező esetben a tömb végére töltjük át az aktuális bináris számot. Ezáltal minden egyes menetben két edény keletkezik: egy, melyben található számok aktuális bitje 0, s egy másik, melyek vizsgált jegye 1-es. Ezt követően a 0-ás edényt az elejéről olvasva feltöltjük újra az eredeti tömböt az előbb ismertetett módon, majd a 1-es edényt elemeit az utolsó elemtől visszafelé haladva töltjük át az értékeket. Amennyiben a rendezendő bináris számok $d$ hosszúak, úgy $d+1$ áttöltést követően rendezett tömböt kapunk.
 \hiddensubsubsection{Példa}
 A bemenet megegyezik a radix "előre" példájában használt számokkal, azaz: $2, 3, 1, 3$, amelyek binárisan a $10, 11, 01, 11$ értékek.\par
 Az első ábra a kezdeti állapotot mutatja. A második képen a tömb első két eleme már áttöltésre került, a 10 az alsó tömb elejére, míg a 11 a végére. A harmadik ábrán látható a teljen áttöltött állapot. A következő ábrán visszatöltésre került az első érték, melynek első bitje 1, így az eredeti tömb végére került. Ekkor a második edény értékeit hátulról előrefelé vizsgáljuk, így a 10 érték kerül először az eredeti tömb elejére, majd a 11 a 10 előtti helyre. Végül az utolsó 11-es érték is bekerül az eredeti tömbbe. Ezt követően az 5. ábrán már csak átmásolásra kerülnek az értékek a megfelelő sorrendben, azaz az egyes edény tartalma előröl olvasva, míg a második edény értékei hátulról előrefelé haladva. \par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=1\textwidth]{pics/radixbackward.jpg}
 	\caption{Példa a radix "vissza" rendezésre}
 \end{figure}
\hiddensubsubsection{Műveletigény}
Lineáris idejű a rendezés, amennyiben $d$ jegyűek a rendezendő számok az algoritmus futási ideje:
$$T(n)=\Theta(d \cdot n) = \Theta(n)$$
\hiddensubsubsection{Jelölések az állapotjelző felületen}
Az aktuálisan vizsgált bit értékének megfelelően, amely bináris szám a 0-ás edénybe kerül \textcolor{swap}{\Huge$\bullet$}, míg amely az 1-es edénybe kerül az \textcolor{select}{\Huge$\bullet$} háttérszínt kap.

\chapter{Fejlesztői dokumentáció}

\section{Tervezés}
A dolgozat fő célja egy olyan elsősorban hallgatóknak szánt program létrehozása, amellyel néhány rendezési algoritmus működése egy letisztult és egyszerű felhasználó felületen keresztül tanulmányozható.\par
A fejlesztés során több szempontot is figyelembe kell venni, úgy mint: műveletigény, memóriaigény, jó megjelenés, egyszerű kezelhetőség, és átlátható-, bővíthető kód készítése. Mivel ezen kritériumok közül több is csak egy másik rovására javítható, ezért a tervezés során kompromisszumokat kell kötni. Továbbá fel kell készülni arra, hogy az eredeti terven a fejlesztés során módosításokat kell végezni, mivel egy-egy probléma megoldása más megközelítést kívánhat.

\subsection{Alapelvek}
A programnak három jól elkülönülő komponensből kell állnia:
Egy logikai(modell) részből, ami gyakorlatilag a rendszer "motorja", itt kell, hogy történjen mindenféle számítási és adattárolási művelet. Egy megjelenítési rétegből, amely a logikai rész eredményeit jeleníti meg a felhasználó számára. Végül pedig egy kontroller szintből, amely kapcsolatot teremt a logikai- és a megjelenítési réteg között. A gyakorlatban ezt a fajta tagolást nevezik Modell-Nézet-Vezérlő \emph{(MVC)} tervezési mintának.\par
Az elsődleges szempont az, hogy a felhasználó könnyedén tudja kezelni a programot, és segítségével megértse az algoritmusok működését. Így a felhasználói felület áttekinthetőségére és letisztultságára nagy hangsúlyt kell fektetni. Továbbá fontos az is, hogy a jövőben további rendezési eljárásokat is könnyedén meg lehessen jeleníteni a jelenlegiek mellett, így fontos a kód egyszerű bővíthetősége.

\subsection{Használt fejlesztőeszközök}
A fejlesztés \emph{Eclipse SDK 4.4} fejlesztői környezet keretei között történik. A program grafikus fejlesztői felületet ad alkalmazások készítéséhez.\par
A kódolást segítő funkció volt a kódkiegészítés, továbbá az egyik beépített projektmenedzsment eszköz(\emph{EGit}).\par
A fejlesztéshez elengedhetetlen a \emph{Java SE 8u40} vagy magasabb verziójú szoftver. Továbbá a fejlesztést nagyban elősegíti a \emph{JavaFX Scene Builder 2.0}, melynek segítségével egyszerűen megtervezhetővé válnak a grafikus felület komponensei.\par
Végül a telepítési környezet létrehozásához \emph{Ant} és \emph{InnoSetup} eszközök kerülnek felhasználásra.
Az egész projekt, beleértve e dokumentumot is megtalálható, és az egyes verziók visszakövethetők a \emph{GitHub}-on: \url{https://github.com/marfoldi/SRTNGLGRTHMS}\par
A program fejlesztése során egyedüli külső függvénykönyvtár a \emph{JUnit}, melynek segítségével egységtesztek készülnek.

\subsection{Felhasználói felület}
\subsubsection{Képernyőtervek}
A program főmenüjében három gomb foglal helyet, melyekre kattintva megadhatók a rendezendő számok. Továbbá az eszköztárban a \textbf{Fájl} és \textbf{Segítség} menüpontok foglalnak helyet, előbbire kattintva lehetőség nyílik a program bezárására, utóbbiban pedig megtekinthető a szoftver névjegye.
\paragraph{Főmenü}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{pics/plan_mainmenu.png}
	\caption{Főmenü látványterv}
\end{figure}
\paragraph{Manuális bemenet}
Az ablakon a \textbf{Méret:} címke mellett található mezővel definiálható a bemenet hossza. A megadását követően megjelennek a hossznak megfelelően beviteli mezők jelennek meg a \textbf{Számok} címkével jelölt részen. A \textbf{Feltöltés} gomb segítségével véletlen számokkal töltődnek fel az előbb említett beviteli mezők. Az \textbf{Ok} gombra történő kattintás után megjelennek a \textbf{Megfigyelés} és \textbf{Összehasonlítás} panelek.
\paragraph{Bemenet generálása}
A \textbf{Méret} címke után megadható a kívánt bemenet hossza. A Típus legördülő listából különböző generálási beállítások választhatóak ki. Az \textbf{Ok} gomb megnyomásával megjelennek a program főpaneljei.
\paragraph{Fájl beolvasása}
A fájlból történő beolvasáshoz nem készült látványterv, mivel egy egyszerű fájltallózó segítségével van lehetősége a felhasználónak számokat ilyen módon megadni.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/plan_input.png}
	\caption{Bemenet megadása látványtervek}
\end{figure}
\paragraph{Főpanelek}
A főpanelek eszköztárában megtalálhatóak a \textbf{Főmenü} pontjai, továbbá lehetőség van az előbb említett felületre történő visszatérésre. A \textbf{Segítség} menüpontban pedig lehetőség van az algoritmusok rövid leírásának megtekintésére. Valamint két gomb segítségével lehet navigálni a \textbf{Megfigyelés-} és \textbf{Összehasonlítás} panelek között.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{pics/plan_panels.png}
	\caption{Főpanelek képernyőterve}
\end{figure}
\paragraph{Megfigyelés panel}
A bal szélen egy algoritmus lista található, melyből kiválasztható a megfigyelni kívánt eljárás. A \textbf{Léptetés} és \textbf{Lejátszás} gombokkal a sárgás színnel jelzett diagramon az algoritmus egy újabb állapota figyelhető meg.
\paragraph{Összehasonlítás panel}
A bal oldalon található táblázatban szerepelnek az algoritmusok által végzett műveletek összegei. A sárga színnel jelölt diagramon megjelennek a kiválasztott algoritmus által végzett összehasonlítások és mozgatások összege.

\subsubsection{Felületek közötti navigálási lehetőségek}
A felületek közti navigálási irányokat a következő diagram szemlélteti:
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{pics/plan_directions.png}
	\caption{Navigálási lehetőségek}
\end{figure}
A főmenüből valamely gombra kattintva elérhetővé válik a kiválasztott típusú bemenet megadása panel. A számok megadásával megjelennek a \textbf{Megfigyelés} és \textbf{Összehasonlítás} panelek. A két panel közötti átjárás egy fülön történő kattintással tehető meg. Ezen paneleken pedig az eszköztár segítségével lehetőség van a \textbf{Főmenü}be való visszatérésre.

\subsection{Használati esetek}
A következőkben a főbb használati esetek kerülnek bemutatásra. A felhasználónak tudnia kell:\par
\begin{description}
	\item[$\bullet$] rendezendő számok sorozatát megadni;
	\item[$\bullet$] algoritmust lejátszani;
	\item[$\bullet$] műveletszámokat összehasonlítani;
	\item[$\bullet$] rendezés leírását elolvasni;
	\item[$\bullet$] program névjegyét megtekinteni;
	\item[$\bullet$] programot bezárni;
	\item[$\bullet$] esetleges hibákról értesülni (például nem megfelelő fájl).
\end{description}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{pics/usecase.png}
	\caption{Használati esetek}
\end{figure}

\subsection{Csomagszerkezet}
Az egyik alapelv, hogy a grafikus megjelenítés működés szintjén minél inkább különüljön el a rendszerlogikától. A grafikus felület már csak a modell programész által számított, a vezérlő programrésznek átadott adatokat jelenítse meg. Továbbá lehetőséget biztosítson a felhasználó számára, hogy vezérelje a program rendszerlogikáját a kontroller rétegen keresztül. Ez által, hogy a rendszerlogika lényegében független a grafikus interfésztől. Így a szoftver magasabb fokú bővíthetőséget, a kód pedig jobb átláthatóságot nyer.\par
 \begin{figure}[H]
 	\centering
 	\includegraphics[width=\textwidth]{pics/packagediagram.png}
 	\caption{A program csomagszerkezete}
 \end{figure}
Ennek tekintetében a programot három fő csomagra kell bontani: A \textbf{modell} csomag, melyben a logikai osztályok találhatóak, a \textbf{view}, melyben a grafikai interfészt leíró \emph{FXML} fájlok és osztályok foglalnak helyet, végül a \textbf{controller} csomag, melynek osztályai kapcsolatot teremtenek a logikai és a megjelenítési réteg között.
\subsubsection{Modell csomag}
A modell osztályok a \textbf{modell} csomag foglalja magában. A pontosabb rendszerezést szem előtt tartva további alcsomagok kerülnek létrehozásra, így jobban áttekinthető az osztályhierarchia. Összességében ebben a csomagban foglalnak helyet azon osztályok, amelyek a rendszer adattároló, rendszerező és számítási feladatait ellátják. Az alábbi táblázat ad áttekintést az előzőleg említett alcsomagokról:\par
\begin{table}[H]
	\def\arraystretch{2}
	\centering
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Név}  & \textbf{Leírás}                                                                          \\ \hline
		algorithm     & A lejátszható algoritmusok implementációját tartalmazza                       \\ \hline
		algorithm.raw & Az "egyszerű" rendezést megvalósító osztályok csomagja\\ \hline
		algorithm.raw.test & A raw csomag osztályaihoz tartozó egységtesztek\\ \hline
		info         & "Az algoritmusról" felugróablakhoz tartozó adatbetöltő                         \\ \hline
	\end{tabular}
\end{table}
\paragraph{algorithm alcsomag}
A csomag osztályainak többsége azon algoritmusimplementációkat tartalmazza, melyek a \textbf{Megfigyelés} panelen megjelennek, azaz számon tartják az algoritmus aktuális állapotát. A csomag további osztályainak a fő funkciója, hogy azon műveleteket, amelyeket több algoritmus is használ legyenek kiemelve, ezáltal megakadályozhatóvá válik a kódismétlés.
\paragraph{algorithm.raw alcsomag}
Azon algoritmusok megvalósítását tartalmazza, amelyekben nem kerül elmentésre a rendezés aktuális állapota. Az általuk szolgáltatott információ mindössze a rendezési feladat megoldása során végzett műveletek száma. Továbbá egy olyan osztályt tartalmaz a csomag, amely ezen adatokat rendezett formában át tudja adni a kontroller rétegnek, melynek segítségével megjelennek az egyes értékek a felhasználói felületen.
\paragraph{algorithm.raw.test alcsomag}
Az előbbi csomag osztályaihoz tartozó egységtesztek osztályait tartalmazza. Néhány egyszerűbb eset kerül tesztelésre, például: üres- és egy elemű tömb, száz; illetve egymillió véletlen generált szám rendezésének eredménye.
\paragraph{info alcsomag}
A felületen egy algoritmust kiválasztva megtekinthető az eljárás rövid leírása. A leírások betöltése fájlból történik. A már lekérdezett szövegeket eltároljuk, így ha a felhasználó ismét lekérdezi az algoritmus leírását már nem szükséges újból beolvasni a fájlt. A csomag e funkciót megvalósító osztályokat tartalmazza.

\subsubsection{Megjelenítő csomag}
A grafikai interfészt leíró \emph{FXML} fájlokat tartalmazza. Ezen fájlokban a felület elemei kerülnek definiálásra, azonosítókkal ellátva, melyek segítségével a \textbf{Vezérlő csomag} osztályai tudnak az egyes komponensekre hivatkozni. Ezen fájlok mindegyikének neve a \textbf{Layout} szuffixet kapta, ezáltal kikövetkeztethető, hogy egy komponens elrendezésének az "tervét" tartalmazzák.\par
\paragraph{graph alcsomag}
A gráf grafikus implementációját tartalmazó csomag.

\subsubsection{Vezérlő csomag}
Osztályai főleg a megjelenítő csomag komponenseihez tartoznak. Ezt az osztályok neve is jelölik, mivel csak a végződésükben(\textbf{Controller}) térnek el az \emph{FXML} fájlok nevétől. Felhasználói interakcióra a modell osztály különböző metódusait hívja meg. Így kapcsolatot teremt az előbb definiált két csomag között. Továbbá tartalmaz egy interfészt, melynek felhasználásával az \textbf{alrogithm.raw} osztály algoritmusai miután befejezték a futásukat figyelmeztetik az interfészt megvalósító osztályt, ami jelen esetben a \textbf{Összehasonlítás} panel táblázatának vezérlő osztálya.

\subsection{Osztályszerkezet}
A következőkben bemutatásra kerülnek a csomagok főbb osztályai, és ezek fontosabb eljárásai. A bemutatásban szereplő osztályok sorrendje többé-kevésbé megegyezik a példányosulásuk sorrendjével. Az ábrán kék színnel vannak jelölve az absztrakt osztályok, míg zöld hátteret kapott az egyik fontosabb interfész.\par
%\afterpage{\null\newpage}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{pics/plan_class.png}
	\caption{A főbb osztályok kapcsolata és kommunikációjuk}
\end{figure}
A megjelenítési réteg fájljai nem kerülnek bemutatásra, mivel ezek szerkezetüket tekintve azonosak, csak a grafikus interfész elemeit definiálják. Amennyiben egy fájl meghívásra kerül a kontroller réteg egyik osztályában az ismertetve lesz.
\subsubsection{alapcsomag osztálya}
\hiddenparagraph{MainApplication}
A \textbf{strnglgrthms} csomag egyetlen osztálya, melyben a program \textbf{main} függvénye található. Létrehozza az ablakot, betölti a menü elrendezését tartalmazó \emph{FXML} fájlt(\textbf{MenuLayout.fxml}).
\subsubsection{controller csomag osztályai}
A felhasználói interakciók hatását ez a réteg érvényesíti, figyeli a felület változásait és adatokat jelenít meg a megjelenítési rétegen.
\hiddenparagraph{MenuController}
Az osztályban található metódusok kezelik a menü eszköztárán való kattintást (\textbf{handleAbout()} és \textbf{handleExit()} függvények). Továbbá a gombokon történő kattintás következtében betöltik a bemenet megadására lehetőséget adó panelekhez tartozó \emph{FXML} fájlokat.
\hiddenparagraph{ManualInputController}
A menüben a \textbf{Manuális} gombra történő kattintás után példányosul az osztály. 
A sikeres bemenet megadását követően átadja a rendezendő elemeket a \textbf{SortingAlgorithm} osztályának. Végül betölti a program főpaneljeit tartalmazó \textbf{BaseLayout.fxml} fájlt.
\hiddenparagraph{RandomInputController}
A \textbf{Véletlen} gombra kattintás következtében példányosul. A kontroller osztály végzi el a számok generálását, mely ezt követően az előbbivel azonosan átadásra kerül a \textbf{SortingAlgorithm} osztálynak. Szintén betölti a főpaneleket tartalmazó \emph{FXML} fájlt.
\hiddenparagraph{FileInputController}
A harmadik gombra kattintás követően keletkezik belőle objektum. Beállítja a fájlkiterjesztés szűrőt és megjeleníti a fájltallózót. Továbbá itt történik meg a fájl tartalmának az ellenőrzése. Az előző két osztállyal azonosan végzi el a bemenő adatok átadását, valamint a főpanelek betöltését.
\hiddenparagraph{BaseController}
A főpanelekhez tartozó kontroller osztály. Figyeli, hogy 100 elemnél hosszabb-e a bemenet, amennyiben igen eltünteti az \textbf{Megfigyelés} panelt. Valamint metódusai kezelik az eszköztár egy elemén való kattintást.
\hiddenparagraph{OverviewController}
A \textbf{Megfigyelés} panel gombjait figyeli és módosítja, például ha befejeződött egy algoritmus, akkor az \textbf{Újraindítás} gombot jeleníti meg a felületen. Továbbá az ezeken történő kattintást kezeli. A \textbf{Léptetés} vagy a \textbf{Lejátszás} gomb megnyomásakor lekérdezi a kiválasztott algoritmust a \textbf{OverviewListController} osztálytól, majd a modell réteg \textbf{SortingAlgorithmFactory} osztályán keresztül elkéri a lejátszandó algoritmus példányát. Végül meghívja a megfelelő \textbf{algorithm} csomagban lévő osztály \textbf{step()} metódusát.
\hiddenparagraph{OverviewListController}
A vizsgálható algoritmusok listáját tartalmazza, amennyiben a felületen módosítás történik a kiválasztott értéken újratölti a megfigyelés panelen látható diagramot, és meghívja a kiválasztott elem \textbf{setDefaults()} függvényét, amellyel az aktuális algoritmus állapotát tároló változók felveszik az alapértéküket.
\hiddenparagraph{OverviewChartController}
A \textbf{Megfigyelés} panelen található diagram kontroller osztálya. A \textbf{SortingAlgorithm} osztály által eltárolt számokat betölti egy listába, majd ezeket megjeleníti az oszlopdiagramon. Az oszlopok színének megváltoztatását is ez az osztály végzi el.
\hiddenparagraph{OverviewDoubleChartController}
Az előbb említett osztálynak két példányát tartalmazza, a \textbf{Radix "vissza"} rendezésnél tölti fel az első példány listáját a rendezendő számokkal, míg a másodikét nullákkal.
\hiddenparagraph{OverviewGraphController}
Az előző két osztállyal megegyező a funkciója. Továbbá "karbantartja" a megjelenített gráfot.
\hiddenparagraph{BenchmarkController}
Példányosulását követően elindítja a \textbf{algorithm.raw} csomag algoritmusait.
Megvalósítja a \textbf{SortingThreadListener} interfészt, ezáltal figyelmeztetést tudnak küldeni neki a \textbf{SortingThread} osztályok ha befejezték futásukat. Feladata az \textbf{Összehasonlítás} felületen a táblázat frissítése, ha egy rendezési feladat megoldódott.
\hiddenparagraph{BenchmarkChartController}
Az \textbf{OverviewChartController} osztályhoz hasonlóan egy diagram kontroller osztálya. A \textbf{Összehasonlítás} panel táblázatának egy elemén történő kattintást kezeli, amennyiben a kiválasztott elem még nem jelenik meg a grafikonon hozzáadja, ellenkező esetben eltávolítja a grafikonról.

\subsubsection{algorithm csomag osztályai}
Főként a lejátszható algoritmusokat tartalmazza. Ezen osztályok mindegyike egyke, azaz a futás során csak egyetlen példány keletkezik belőlük.
\hiddenparagraph{TournamentSort}
Mivel mindegyik rendezést megvalósító osztály kevéssé tér el egymástól, ezért csak egy kerül rövid ismertetésre.
\par Alapértelmezetten mindegyik osztály tartalmaz egy \textbf{step()} metódust, amely egy következő állapotba lépteti a rendezést. Minden osztályhoz a rendezést megvalósító változókon felül tartoznak olyan logikai változók, amelyekben az aktuális állapot egy-egy tulajdonsága elmentésre kerül. Ilyen változóban tárolódik például az, hogy a \textbf{Versenyrendezés} bináris fájában megtaláltuk-e a maximális elemhez tartozó levélelemet.
\hiddenparagraph{SortingAlgorithm}
A rendezést megvalósító osztályok őse a \textbf{SortingAlgorithm} absztrakt osztály. Néhány olyan metódust valósíst meg, amelyek minden rendezésnél azonosak.
\hiddenparagraph{ChartAlgorithm}
Az előbb említett osztály absztrakt "gyereke", továbbá azon rendezést megvalósító osztályok ősosztálya, amelyek megjelenítéskor csak oszlopdiagramokat használnak.
\hiddenparagraph{RadixAlgorithm}
A \textbf{ChartAlgorithm} osztály absztrakt leszármazottja. A radix rendezések ősosztálya. Néhány olyan metódust tartalmaz, amelyeket mindkét rendezés használ.
\hiddenparagraph{GraphAlgorithm}
Szintén a \textbf{SortingAlgorithm} absztrakt "gyereke", és azon osztályok őse, melyek a grafikus megjelenítéskor oszlopdiagramot és gráfot is használnak.
\hiddenparagraph{SortingAlgorithmFactory}
A \textbf{SortingAlgorithm} osztályok gyártó osztálya, az egyetlen \textbf{getAlgorithm(String algorithmName)} metódusa a paraméter tartalmától függően visszaadja a kért algoritmus példányát.
\hiddenparagraph{RecursiveParameter}
Néhány adat eltárolására használt osztály. Például a gyorsrendezés megvalósításakor a rekurzív hívások elmentése ilyen objektumokat tartalmazó listába történik.

\subsubsection{alogirtmh.raw csomag osztályai}
Azon rendezések implementációját tartalmazza, amelyek megjelennek az \textbf{Összehasonlítás} panelen. Ezen osztályok mindegyike egy külön szálat hoz létre, amely szálak befejeződésüket követően figyelmeztetik a már ismertetett \textbf{BenchmarkController} osztályt.
\hiddenparagraph{InsertionSortThread}
Az előző csomag osztályaihoz hasonlóan, mivel ezen osztályok minimálisan térnek el felépítésüket tekintve csak egy osztály kerül rövid jellemzésre. A \textbf{sort()} metódus hívására egy programszálat indít el, amely elvégzi a rendezést majd átadja a műveletszámot a \textbf{BenchmarkController} osztálynak. 
\hiddenparagraph{SortingThread}
Az előbb említett osztálytípusok őse. Néhány olyan metódust valósíst meg, amelyek minden rendezésnél azonosak. Továbbá tartalmazza a műveletek összegzéséhez használt változókat.
\hiddenparagraph{BenchmarkData}
Egy rendezés a befejeződését követően példányosít belőle egy objektumot. Eltárolja az algoritmus által végzett összehasonlítások és mozgatások vagy cserék számát. Ilyen példány kerül átadásra a \textbf{BenchmarkController} osztály számára, amely ezekből listát készít.

\subsubsection{info csomag osztályai}
A két osztálya megvalósítja a pehelysúlyú programtervezési mintát. A minta használatának oka az, hogy a felhasználó egy adott algoritmushoz többször is lekérheti a leírást. Ekkor felesleges ismételten fájlból beolvasni a szöveget, mivel az nem változott. Célszerű ilyenkor a már lekért adatokat elmenteni, és azt visszaadni ha újra hivatkozás történik rá.
\hiddenparagraph{InfoFlyWeight}
Az osztály egyetlen adattagja egy \textbf{String}. Ebben a változóban tárolódik egy algoritmus leírásának a szövege.
\hiddenparagraph{InfoFlyWeightFactory}
Az osztály eltárolja a már betöltött szövegeket.
A \textbf{BaseController} osztály \textbf{handleAbout()} függvénye az algoritmus listából aktuálisan kiválasztott elem szöveges reprezentációjával meghívja az osztály \textbf{getInfo(String algorithmName)} függvényét. A függvény megnézi, hogy már tárolásra került-e az algoritmushoz tartozó szöveg. Amennyiben igen, azt az objektumot adja vissza. Ellenkező esetben beolvassa a fájlt, és elmenti a szöveget egy InfoFlyWeight objektumba. Ezzel egyidejűleg az "új" algoritmus szövege is tárolásra kerül.


\section{Megvalósítás}
\subsection{Az eredeti terv módosítása}
A megvalósítás során néhány ponton módosítást kellett eszközölni az eredeti terveken.
\subsubsection{Szálkezelés}
Eredetileg egy-egy külön szálon futottak volna az algoritmusok, és a felhasználói interakció hatására ezek állapota változott volna. Azonban a \emph{JavaFX} szálkezelése jelentősen eltér az szokványos szálkezelésétől, ezért járhatóbb útnak bizonyult az ha kétszer kerüljenek implementálásra az algoritmusok. Így került kialakításra a \textbf{algorithm.raw} csomag.\par
 Az egyik implementációban elmentjük az interakciót követő állapotot, és ez jelenik meg a felhasználói felületen. A másik megvalósításban pedig a rendezések azonnal lezajlanak, így képet kaphatunk arról, hogy mennyi műveletre volt szükség az egyes eljárások során. Ezen utóbbi implementációk mindegyike külön szálon fut, és ahogy valamelyik befejeződik figyelmezteti a főprogramot, hogy jelenítse meg a műveletek számát.
\subsubsection{A JavaFX kibővítése}
A szoftver erősen épít a \emph{JavaFX} adta felületi komponensekre. Azonban akad olyan összetevő, amelyet ki kell bővíteni, vagy létre kell hozni az áttekinthetőség érdekében.\par
Ilyen például az oszlopdiagram, amely ugyan beépített komponens, de alapértelmezetten nem jelennek meg a diagramon az oszlopokhoz tartozó értékek számszerűen, csak a tengelyszámokból lehet kikövetkeztetni őket. Ez nyilvánvalóan így nem megfelelő, az oszlopok értékét valahogy jelölni a megjelenítéskor. A legegyszerűbb megoldás az, ha mindegyik oszlopérték felé egy feliratot(\emph{Label}-t) helyezünk el. Figyelni kell a szöveghez tartozó oszlop méretét. Amint megváltozik az diagram egy elemének a mérete módosítani kell a felette lévő szövegdobozban tárolt számot is.\par
Továbbá a \emph{JavaFX} egyelőre nem kínál lehetőséget gráfok ábrázolására, itt megoldás lehet az, hogy egy külső függvénykönyvtárat felhasználva - például az \emph{yFiles for JavaFX}-et -  ábrázoljuk a bináris fákat. Azonban ezáltal a programnak több függősége lenne, és a könyvtárnak csupán néhány elemére van szükség a gráf megjelenítéséhez. Ezért célszerűbb egy saját implementációt készíteni, amely csupán azokat a műveleteket tartalmazza, amiket a szoftver használ.

\subsection{A megvalósítás menete}
Az első lépés volt a rendezési algoritmusok implementálása. Itt az előző alfejezetben leírtaknak megfelelően kétszer kell elkészíteni a rendezési eljárásokat. Ezzel egyidejűleg minden "egyszerű" rendezést megvalósító szálhoz egységteszteket kell írni.\par
Ezt követhette egyszerűbb felhasználói felület létrehozása. Kezdetben elegendő, ha csak egy grafikon jelenik meg, amely reprezentálja a tömbben található számokat.\par
Két algoritmushoz szükséges a gráfos megjelenítés, így a következő lépés egy gráf grafikus implementálása.
Ezt követően a cél, hogy néhány "beégetett" elemre a rendezések lejátszhatóak legyenek, és az aktuális állapota a tömbnek szinkronban legyen a diagrammal valamint a gráffal. Később az egyes lépésekben történő összehasonlításokat/vizsgálatokat, mozgatásokat, cseréket kell különböző színekkel jelölni az állapotjelző felületeken és számon tartani ezen műveletek összegeit.\par
Miután a program alapjai elkészültek kezdetét veheti a a felhasználói felület részletes kialakítása. Elsőként a diagram elhelyezése egy panelen, amely tartalmaz továbbá egy listát a választható algoritmusokról. Illetve egy táblázatot, melyben szerepelnek az aktuális állapot egyes tulajdonságai.\par
A programnak egy fontos szolgáltatása az, hogy a felhasználó különböző adatbeviteli mód közül választhat. A logikai réteget ki kell bővíteni ezekkel az esetekkel, továbbá a felhasználói felületen lehetőséget adni ezen módok kiválasztására.\par
Ezután az eszköztár kerül a helyére, mellyel párhuzamosan megtörténik az egyes műveletekhez tartozó eljárások implementálása.\par
Az utolsó felületi módosítás egy rendezések összehasonlítására lehetőséget adó panel létrehozása, táblázattal, benne az algoritmusok műveletigényével. Továbbá egy diagram hozzáadása, amin megjelenik a táblázatból kiválasztott sor összehasonlításainak és mozgatásainak a száma.\par
Végül, hogy a program egyszerűen használható legyen \emph{Windows} környezetben egy telepítő fájl készítése, amellyel az előbb említett operációs rendszert használóknak nem szükséges külön \emph{Java}-t telepíteniük.

\subsection{FXML állományok}
Az \emph{FXML} az \emph{Oracle} által fejlesztett dekleratív XML alapú nyelv\cite{FXML}. Ezen fájlok definiálják a grafikus felület komponenseit. Egy ilyen fájl a következőképp épül fel:
\begin{description}
	\item[$\bullet$] Az első sor mindig az XML tulajdonságokat definiáló sor
	\item[$\bullet$] A következő sorokban található azon könyvtárak importálása, amelyekben megtalálhatók a felhasznált komponensek
	\item[$\bullet$] Ezt követi az ablak elrendezési módjának a megadása, ekkor több beépített megvalósítás közül lehet választani, többek között:
		\begin{description}
		\item[$\diamond$] \emph{BorderPane} - 5 pozícióba helyezhetőek elemek
		\item[$\diamond$] \emph{GridPane} - táblázatszerűen jelennek meg az elemei
		\item[$\diamond$] \emph{AnchorPane} - egy "szimpla" felület, nincs megkötés	
		\end{description}
	Továbbá ebben a sorban kell megadni az \emph{FXML} állományhoz tartozó kontroller osztály elérési útvonalát. Az vezérlőosztály tud hivatkozni az egyes összetevőkre az azonosítójukon keresztül.
	\item[$\bullet$] Végül a komponensek definiálása: méretük, azonosítójuk megadásával.
\end{description}
\subsubsection{Néhány fontosabb FXML állomány}
A következőkben bemutatásra kerülnek a projekt főbb \emph{FXML} fájljai.
\paragraph{BaseController}
Az egyik "összefogó" \emph{FXML} fájl. A rendezendő számok megadása után minden esetben ez az állomány töltődik be. Alapvetően a fejlécet és egy \textbf{TabPane} komponenst tartalmaz, ami a két panel közötti navigálást teszi lehetővé. Ezeken felül importálva van két további állomány is: az \textbf{OverviewLayout} és a \textbf{BenchmarkLayout}. Ennek következtében, amikor a \textbf{BaseController} betöltődik vele együtt az előbb említett két fájl is beolvasásra kerül minden további komponensükkel.
\paragraph{OverviewLayout}
Szintén több komponenst foglal magában, a \textbf{Megfigyelés} panelt gombjait és a más fájlokból betöltött komponensek elhelyezkedését definiálja. Az általa importált további állományok: \textbf{OverviewListLayout}, \textbf{OverviewTableLayout}, továbbá az aktuálisan kiválasztott algoritmus típusától függően a \textbf{OverviewChartLayout}, \textbf{OverviewDoubleChartLayout} vagy \textbf{OverviewGraphLayout} valamelyike.
\paragraph{BenchmarkLayout}
Az \textbf{Összehasonlítás} panel részeinek elhelyezkedését írja le. A következő \emph{FXML} fájlokat hívja meg betöltésekor: \textbf{BenchmarkTableLayout}, \textbf{BenchmarkChartLayout}.

\subsection{Nem forrásfájl állományok}
A program által használt nem forrás- vagy \emph{FXML} fájlok a \textbf{resources} mappában találhatóak. Ezen belül az \textbf{images} könyvtárban található meg a szoftver ikonja. A \textbf{text} mappán belül találhatóak azon fájlok, amelyeket az \textbf{InfoFlyWeight} osztály betölt. Azaz ezekben az állományokban található meg az egyes algoritmusok rövid ismertetése. A harmadik \textbf{input} mappában a fájlból történő bemenet megadásához található néhány példaadat.

\subsection{Osztályok leírása}
Az előző fejezetben(3.1) ismertetésre kerültek a főbb osztályok és azok fontosabb eljárásai, a következőkben nagyobb részletességgel kerülnek jellemzésre a szoftver osztályai.
\subsubsection{Modell réteg osztályai}
Elsőként a \textbf{algorithm} csomag főbb osztályai kerülnek ismertetésre.
\paragraph{SortingAlgorithm absztrakt osztály}
A \textbf{Megfigyelés} panelen megjelenő algoritmusok osztályainak őse. Az osztály \textbf{numbers} statikus adattagjában kerül eltárolásra a bemenetkor megadott számsorozat. További két adattagja egy rekurzív hívások mentésére szolgáló- és egy \textbf{CounterData} objektumokat tartalmazó lista.\par
A \textbf{getMaximum()} eljárás visszaadja a \textbf{numbers} tömb maximális elemét. A függvénynek a megjelenítéshez használt oszlopdiagram lépésközének definiálásánál van szerepe. Továbbá tartalmaz három absztrakt eljárást, amelyeket a leszármazott osztályai valósítanak meg.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/SortingAlgorithm.png}
	\caption{A SortingAlgorithm osztálydiagramja}
\end{figure}
\paragraph{ChartAlgorithm absztrakt osztály}
Az előző osztály leszármazottja, megvalósítja a \textbf{swap(int firstIndex, int secondIndex)} metódusát. A diagram kontroller osztálya a rendezendő számokat egy \textbf{ObservableList} adatszerkezetben tárolja, így ennek megfelelően került az eljárás implementálásra. A kontroller réteg előbb említett listáját statikus változóként elmenti, így a leszármazott osztályai egyszerűbben tudnak hivatkozni az egyes értékekre.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/ChartAlgorithm.png}
	\caption{A ChartAlgorithm osztálydiagramja}
\end{figure}
\paragraph{GraphAlgorithm absztrakt osztály}
Szintén a \textbf{SortingAlgorithm} leszármazott absztrakt osztálya. A \textbf{GraphController} osztály gráfját és csúcsait tárolja, így a leszármazott osztályai egyszerűbb elérik ezeket az adattagokat.\par
Továbbá ellenőrzi a bemenet hosszát, és ha szükséges "csonkolja" vagy megnöveli az eredeti tömb hosszát a \textbf{checkLength(int[] numbers, String algorithm)} metódusa. Megvalósítja az előző osztályhoz hasonlóan a \textbf{swap(int firstIndex, int secondIndex)} metódust. Valamint a \textbf{setRestColor(int index)} metódusa a paraméterül kapott indexig visszaállítja az eredeti színűre a \textbf{Megfigyelés} panelen megjelenített gráfcsúcsokat, valamint a oszlopokat.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/GraphAlgorithm.png}
	\caption{A GraphAlgorithm osztálydiagramja}
\end{figure}
\paragraph{RadixAlgorithm absztrakt osztály}
A \textbf{ChartAlgorithm} leszármazott absztrakt osztálya. Továbbá a radix eljárásokat megvalósító osztályok őse. A két származtatottjának adattagjai már itt definiálásra kerülnek, azaz négy "pointer", valamint az aktuálisan vizsgált számjegy indexe(\textbf{actualDigit}).\par
A \textbf{getMaxDigit()} metódusa visszaadja a leghosszabb bináris számot, amelyet a másik \textbf{fillWithZeros(String binaryNumber)} metódus fel is használ, mivel ennek megfelelően a rövidebb számokat nullákkal konkatenálja.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/RadixAlgorithm.png}
	\caption{A GraphAlgorithm osztálydiagramja}
\end{figure}
\paragraph{SortingAlgorithmFactory osztály}
Létrehozásakor a gyártó metódus programtervezési minta lett alapul véve. Ezen az osztályon keresztül kérhetőek el az algoritmusok példányai, függetlenül attól, hogy az aktuális algoritmus őse a \textbf{ChartAlgorithm} vagy a \textbf{GraphAlgorithm} osztály.\par
Egyetlen metódusának paramétere egy algoritmus szöveges reprezentációja, például: "Gyorsrendezés". Az eljárás visszaadja a rendezést megvalósító osztály példányát. Elsősorban a kontroller réteg \textbf{AlgorithmList} osztálya használja.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/SortingAlgorithmFactory.png}
	\caption{A SortingAlgorithmFactory osztálydiagramja}
\end{figure}
\paragraph{CounterData osztály}
Az osztály segítségével adatok tárolhatóak kulcs-érték párban. Az implementációval kapcsolatban felmerülhet a kérdés, hogy miért nem a \emph{Java} nyelv egy beépített adatszerkezete került felhasználásra. Ennek oka, hogy a felhasználói felületen lévő táblázatok csak olyan adatszerkezetet tudnak megjeleníteni, amelynek adattagjainak a típusa \textbf{Property} végződésű, és implementálva vannak ezekhez a mezőkhöz a \textbf{getter} metódusok.\par
 Az algoritmusokat megvalósító osztályok ilyen adatokból álló listában tárolják az egyes "tulajdonságaikat", és adják át a vezérlőrétegnek. A vezérlőréteg pedig a \textbf{Megfigyelés} panel táblázatában jeleníti meg az értékeket.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/CounterData.png}
	\caption{A CounterData osztálydiagramja}
\end{figure}
\paragraph{RecursiveParameter osztály}
Funkciója hasonló az előbb ismertetett osztályéhoz, azaz adatok tárolására lett létrehozva. Legfeljebb négy érték elmentésére alkalmas. Azon algoritmusok, amelyek rekurziót használnak ezen objektumokból álló listába mentik el a rekurzív hívások paramétereit. A konstruktora túlterhelt, azaz legalább kettő, maximum négy paraméterrel hívható.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{pics/class/RecursiveParameter.png}
	\caption{A RecursiveParameter osztálydiagramja}
\end{figure}
A következőkben az algoritmusok lejátszását megvalósító konkrét osztályokat jellemezzük, melyek szintén az \textbf{algorithm} csomagban találhatóak. Az osztályok mindegyike egyke, azaz a program futása során egyetlen példány keletkezik belőlük.
\paragraph{BubbleSort osztály}
A buborékrendezést megvalósító egyke osztály. Ősosztálya a \textbf{ChartAlgorithm} Két változója megfelel az algoritmus két ciklusváltozójának. Konstruktora privát, a \textbf{getInstance()} metódusán keresztül kérhető le a példánya. Amennyiben nincs még létrehozva példány elkészíti, ellenkező esetben visszaadja a már létrehozott objektumot.\par
Az egyke tulajdonságból következően azokat a változókat melyekben tárolódik a rendezés aktuális állapota minden futtatás után vissza kell állítani az eredeti értékre, ezt a \textbf{setDefaults()} függvény teszi meg. Továbbá ez a metódus hozza létre a tulajdonságokat tartalmazó \textbf{CounterData} objektumokat.\par
A \textbf{step()} örökölt eljárás egy rendezési lépést hajt végre. A \textbf{setDefaults()} metódus pedig visszaállítja a \textbf{Megfigyelés} panelen látható diagramok színét az alapértékre.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BubbleSort.png}
	\caption{A BubbleSort osztálydiagramja}
\end{figure}
\paragraph{InsertionSort osztály}
A beszúró rendezést megvalósító osztály. Alapvetően felépítését és függvényeit tekintve megegyezik a \textbf{BubbleSort} osztálynál leírtakkal. Különbség, hogy két további logikai változóval rendelkezik. Az \textbf{isSelected} mezőben tárolódik az az információ, hogy már kiválasztásra került-e egy elem, mivel a \textbf{step()} metódus ennek megfelelően hajtja végre a következő lépést. Továbbá a \textbf{showSwapped} változó értéke adja meg, hogy a felületen megjelenítésre került-e egy mozgatás.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/InsertionSort.png}
	\caption{Az InsertionSort osztálydiagramja}
\end{figure}
\paragraph{ShellSort osztály}
A Shell rendezést megvalósító osztály. Őse, akárcsak az eddigi osztályoknak a \textbf{ChartAlgorithm}. A \textbf{BubbleSort}-nál leírtakkal lehet jellemezni, viszont tartalmaz néhány további változót és eljárást. A \textbf{gapArray} tömbben tárolódnak a lépésközök, az aktuális lépésköz a \textbf{gapIndex} változó segítségével kérhető le a tömbből. Az \textbf{InsertionSort}-nál leírtakkal megegyező szerepet tölt be a \textbf{isSelected} változó.\par
A \textbf{generateGapArray()} eljárás feltölti a lépésközöket tároló tömböt a bemenet méretétől függően a \textbf{Vaughan Pratt} által javasolt értékekkel\cite{Pratt}. Az implementációban a legutóbbi tömbhöz adott számot kettővel és hárommal szorozzuk, és számon tartjuk, hogy egy lépésben melyik szorzást végeztük el. Amikor elértük azt az értéket, amely nagyobb vagy egyenlő a tömb hosszával, akkor befejezzük a számok generálását, az utolsó érték nem lesz eleme a tömbnek.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/ShellSort.png}
	\caption{A ShellSort osztálydiagramja}
\end{figure}
\paragraph{QuickSort osztály}
A gyorsrendezés implementációja. Őse szintén a \textbf{ChartAlgorithm} osztály. A \textbf{begin} és \textbf{end} változói jelölik az aktuálisan rendezendő tömbrész első és utolsó elemét. A \textbf{partitionIndex} és \textbf{partitionHelpIndex} mezőknek a tömb felosztásánál van szerepük. A \textbf{pivot} változóban tárolódik a vezérelem értéke, melynek indexét a \textbf{pivotIndex} tartalmazza. A \textbf{isPartitioned} logikai változó értéke mutatja, hogy megtörtént-e a tömb felosztása. Az osztály használja a \textbf{SortingAlgorithm} ősének a \textbf{recursiveCall} listáját, ide menti el a rekurzív hívásokhoz szükséges adatokat.\par
A \textbf{setDefaults()} metódus működése megegyezik az eddigiekkel. A \textbf{setRestColor()} eljárás viszont két egész számot vár paraméterként, és a két szám által meghatározott intervallumon kívül eső részen az oszlopdiagramok színét fakóra állítja át a vezérlő rétegen keresztül.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/QuickSort.png}
	\caption{A QuickSort osztálydiagramja}
\end{figure}
\paragraph{HeapSort osztály}
Őse a \textbf{GraphAlgorithm} osztály, a kupacrendezést valósítja meg.\par
A \textbf{starterIndex} változó tárolja azon elemét indexét, melynek vizsgáljuk a testvér-szülő "viszonyát". A \textbf{downIndex} segédváltozóban tárolódik a kupac tulajdonság ellenőrzésekor azon elem indexe, amelyet következőleg vizsgálni kell. A \textbf{recursiveCounter} megfeleltethető a kupacrendezés eljárás ciklusváltozójának. Továbbá három logikai mezővel rendelkezik az osztály, melyek közül a \textbf{isColored} jelöli, hogy már a diagramon megváltozott-e a vizsgált elemek színe. A \textbf{canSwap} változó értékétől függően hajtja végre az algoritmus a cseréket, mivel ez csak azt követően eszközölhető, ha már kijelölődtek a cserélendő elemek a \textbf{Megfigyelés} panelen. A \textbf{downIndexSetted} segédváltozó amennyiben igaz, akkor már megtörtént a kupac felépítése az első menetben, innentől kezdve a gyökérelemtől kell vizsgálni a kupactulajdonságot, így ennek megfelelően átállítódik a \textbf{downIndex} értéke 0-ra.\par
Az átláthatóságot szem előtt tartva a \textbf{step()} metódusból kiemelésre került a kupac(újra)építés eljárása, melyet a \textbf{buildHeap(int startIndex, int endIndex, boolean firstRun)} metódus valósít meg. A harmadik paramétere határozza meg, hogy alapkupac építése-e a feladat vagy a kupactulajdonság ellenőrzése. Az eljárás visszatérési értéke a következő vizsgálandó elem. A \textbf{setDefaultGraph()} függvény építi fel a bináris fát a rendezendő számokból, majd adja át a vezérlőrétegnek megjelenítésre.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/HeapSort.png}
	\caption{A HeapSort osztálydiagramja}
\end{figure}
\paragraph{TournamentSort osztály}
A versenyrendezést megvalósító egyke osztály, melynek őse az előző osztályhoz hasonlóan a \textbf{GraphAlgorithm}.\par
A \textbf{fillIndex} a versenyfa felépítésekor tárolja azon elem indexét, amelynek gyerekeit "versenyeztetjük". Akárcsak az előbb jellemzett osztálynál, itt is megfeleltethető a \textbf{recursiveCounter} változó az algoritmus ciklusváltozójának. A \textbf{maxIndex} mező tárolja a maximális levélelem keresésekor az egyik megtalált belső csúcsot. Az \textbf{outIndex} segítségével pedig elérjük egy maximális elem megtalálásakor a \textbf{Megfigyelés} panel oszlopdiagramjának egy adott oszlopát.\par
A \textbf{setDefaultGraph()} és \textbf{step()} eljárás funkciója megegyezik a \textbf{HeapSort}-nál leírtakkal.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/TournamentSort.png}
	\caption{A TournamentSort osztálydiagramja}
\end{figure}
\paragraph{ForwardRadix osztály}
Őse a \textbf{RadixAlgorithm} osztály, a radix "előre" rendezést valósítja meg.
Az \textbf{isLowerFound} és \textbf{isUpperFound} változók tárolják, hogy egy adott lépésben talált-e az algoritmus olyan értéket, amely nem a megfelelő helyen van. Továbbá az \textbf{isColored} logikai mező értéke megadja, hogy egy cserélendő elem színe megváltozott-e már a felületen.\par
A \textbf{setBucketColor(int lower, int upper)} eljárás a két paraméterül kapott intervallumon beállíttatja a kontroller rétegben az oszlopok színét egységesre, így kijelöl egy edényt. A \textbf{step()} metódus használja az örökölt \textbf{recursiveCall} listát.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/ForwardRadix.png}
	\caption{A ForwardRadix osztálydiagramja}
\end{figure}
\paragraph{BackwardRadix osztály}
A radix "vissza" rendezést valósítja meg, ősosztálya a \textbf{RadixAlgorithm}.
Az \textbf{index} változó tárolja az aktuálisan vizsgált elem indexét. Az \textbf{actualSeries} azt a tömböt, amelyben vizsgálni kell az elemeket. A \textbf{direction} változó megadja, hogy az aktuális résztömbön mely irányból kell végezni a vizsgálatot. A \textbf{listOne} és \textbf{listTwo} változók megfeleltethetőek az algoritmus által használt két tömbnek.\par
A \textbf{step()} metódus használja az örökölt \textbf{recursiveCall} listát.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BackwardRadix.png}
	\caption{A BackwardRadix osztálydiagramja}
\end{figure}
Most az \textbf{algorithm.raw} csomag főbb osztályai kerülnek jellemzésre.
\paragraph{BenchmarkData osztály}
A \textbf{CounterData} osztályhoz hasonló a funkciója és felépítése. Az algoritmus nevét és a rendezés során végzett műveletek összegét tárolja. A kontroller réteg használja fel a \textbf{Összehasonlítás} panel táblázatának a kitöltéséhez. Minden rendezést végző programszál létrehoz belőle egy objektumot, majd hozzáadja egy listához, amit a kontroller réteg lekér egy szál befejeződésekor.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BenchmarkData.png}
	\caption{A BenchmarkData osztálydiagramja}
\end{figure}
\paragraph{SortingThread absztrakt osztály}
A csomagban található rendezést megvalósító osztályok szülője. Őse a \textbf{Thread} osztály. A \textbf{SortingThreadListener} mezője tárolja azt az objektumot(\textbf{BenchmarkController}), amelyet a szál befejeződése után figyelmeztet. Továbbá adattagjai tárolják a rendezés során végzett műveletek számát.
A leszármazott osztályai a \textbf{doRun()} metódusát valósítják meg, amely a programszál elindításakor hívódik meg. 
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/SortingThread.png}
	\caption{A SortingThread osztálydiagramja}
\end{figure}
A következőkben az \textbf{Összehasonlítás} panelen megjelenő információkhoz adatokat szolgáltató konkrét osztályok kerülnek jellemzésre.
\paragraph{BubbleSortThread osztály}
Megvalósítja az előbb említett \textbf{doRun()} metódust. Elvégzi a rendezést, majd a feladat befejeztével a kontroller réteg \textbf{BenchmarkController} osztályában található \textbf{BenchmarkDataList} listához hozzáfűz egy új \textbf{BenchmarkData} objektumot.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BubbleSortThread.png}
	\caption{A BubbleSortThread osztálydiagramja}
\end{figure}
\paragraph{InsertionSortThread osztály}
Őse a \textbf{SortingThread} osztály. Felépítése teljesen azonos a \textbf{BubbleSortThread} jellemzésénél leírtakkal. Ennélfogva az osztálydiagramban sincs eltérés.
\paragraph{ShellSortThread osztály}
Az egyetlen különbség az előző osztályokhoz képest, hogy rendelkezik egy további metódussal. A \textbf{generateGapArray()} metódus megegyezik a \textbf{ShellSort} osztály jellemzésében szereplő azonos nevű függvénnyel.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/ShellSortThread.png}
	\caption{A ShellSortThread osztálydiagramja}
\end{figure}
\paragraph{QuickSortThead osztály}
Két további metódussal rendelkezik, ezektől eltekintve megegyezik az \textbf{BubbleSortThead} felépítésével. A \textbf{doRun()} metódusból kiemelésre került a tömb felosztását végző függvény(\textbf{partition(int[] numbers, int begin, int end)}), valamint a rekurzív hívásokat végző \textbf{quickSort(int[] numbers, int begin, int end)} eljárás.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/QuickSortThread.png}
	\caption{A QuickSortThread osztálydiagramja}
\end{figure}
\paragraph{HeapSortThread osztály}
A \textbf{QuickSortThread}-hez hasonlóan két metódus került kiemelésre a \textbf{doRun()} metódusból. Az egyik a \textbf{buildStarterHeap(int[] numbers)} eljárás, amely felépíti a kezdőkupacot. Továbbá a \textbf{buildHeap(int[] numbers, int begin, int end)} függvény, amely ellenőrzi a kupactulajdonságot.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/HeapSortThread.png}
	\caption{A HeapSortThread osztálydiagramja}
\end{figure}
\paragraph{TournamentSortThread osztály}
Felépítését tekintve a \textbf{BubbleSortThread}-nál leírtakon felül egy egész számokat tartalmazó tömb adattagja van. Ez a tesztelés miatt került kiemelésre, mivel az algoritmus amennyiben nem kettő hatvány a bemenet hossza további (-1) értékekkel tölti fel a tömböt, amíg nem lesz megfelelő a mérete.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/TournamentSortThread.png}
	\caption{A TournamentSortThread osztálydiagramja}
\end{figure}
Az \textbf{info} alcsomag osztályai kerülnek bemutatásra
\paragraph{InfoFlyWeight osztály}
Egyetlen adattagja egy szöveges mező. Ebben a változóban tárolódik egy algoritmushoz tartozó leírás.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/InfoFlyWeight.png}
	\caption{Az InfoFlyWeight osztálydiagramja}
\end{figure}
\paragraph{InfoFlyWeightFactory osztály}
Az előző osztály közreműködésével megvalósítja a pehelysúlyú programtervezési mintát. Mivel a felhasználó többször is lekérheti egy algoritmus leírását, ezért célszerű egy objektumban tárolni ezt az adatot, így nem szükséges minden lekérésnél újra betölteni a leírást tartalmazó fájlt. Egy \textbf{HashMap} adatszerkezetben kulcs-érték párokként tárolódnak a már betöltött algoritmusleírások.\par
A \textbf{String getInfo(String algorithmName)} metódusa ellenőrzi, hogy a paraméterként kapott algoritmus név (például: Gyorsrendezés) kulcs szerepel-e a \textbf{HashMap}-ben. Amennyiben igen, visszaadja a kulcshoz tartozó \textbf{InfoFlyWeight} objektumot. Ellenkező esetben betölti az algoritmus leírását, példányosít egy új \textbf{InfoFlyWeight}-et, majd hozzáfűzi a \textbf{HashMap}-hez.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/InfoFlyWeightFactory.png}
	\caption{Az InfoFlyWeightFactory osztálydiagramja}
\end{figure}
\subsubsection{Kontroller réteg osztályai}
\paragraph{MainApplication osztály}
Ugyan az alapcsomag része, funkcionalitását tekintve mégis a kontroller osztályok közé sorolható. Az osztály tartalmazza a program \textbf{main()} metódusát. A szoftver indításakor ez a metódus hívódik meg.\par
A \textbf{start()} függvény létrehoz egy "színpadot"(\textbf{Stage}), amely az ablaknak felel meg. Beállítja az ablak címsorát, betölti az alkalmazás ikonját. Majd meghívja a \textbf{InitMenuLayout} metódust.\par
Az imént említett eljárás betölti a főmenü elrendezését tartalmazó \emph{FXML} fájlt, azaz a \textbf{MenuLayout.fxml}-t.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/MainApplication.png}
	\caption{A MainApplication osztálydiagramja}
\end{figure}
\paragraph{MenuController osztály}
A \textbf{MenuLayout.fxml} fájl betöltésével egyidejűleg példányosul. A felület eszköztárán a \textbf{Segítség -> Névjegy} pontjára kattintva fut le a \textbf{handleAbout()} metódus. Megjelenít egy \textbf{alertBoxot}, benne a program névjegyének szövegével. Továbbá a \textbf{Fájl -> Bezárás} eszköztár elemet kiválasztva meghívódik a szoftver leállását eredményező \textbf{handleExit()} eljárás. A további függvényei a \textbf{MenuLayout.fxml} fájlban definiált gombokon történő kattintást kezelik, és betöltik a kiválasztott bemenettípushoz tartozó \emph{FXML} fájlt.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/MenuController.png}
	\caption{A MenuController osztálydiagramja}
\end{figure}
\paragraph{ManualInputController osztály}
A \textbf{ManualInputLayout.fxml} fájl betöltésével példányosul, ekkor lefut az \textbf{initialize()} metódus, mely letiltja a kattintást a felület két gombján.
\par A \textbf{setSizeLimit()} metódus figyeli a méret mező tartalmát, amennyiben nem pozitív egész szám a gombok továbbra is tiltva maradnak. Továbbá, ha a megadott hossz nagyobb száznál, akkor automatikusan átírja az értéket 100-ra. Amennyiben a méret megadása sikeres meghívódik a \textbf{createFields()} eljárás, mely létrehozza a számok beírására lehetőséged adó mezőket.\par
A \textbf{randomBtnHandler()} metódus a \textbf{Feltöltés} gombon történő kattintást követően fut le. Ekkor feltölti a létrehozott mezőket 0 és 100 közötti véletlen számokkal. A \textbf{saveNumbers()} metódus átadja a rendezendő számokat a \textbf{SortingAlgorithm} osztályának. Ezt követően betölti a program főpaneljeit tartalmazó \textbf{BaseLayout.fxml} fájlt.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/ManualInputController.png}
	\caption{A ManualInputController osztálydiagramja}
\end{figure}
\paragraph{RandomInputController osztály}
A \textbf{RandomInputLayout.fxml} fájl betöltésekor jön létre belőle egy példány. Ekkor az \textbf{initialize()} metódus eljárás letiltja az \textbf{Ok} gombon való kattintást, továbbá meghívja az \textbf{initBox()} függvényt.\par
Az imént említett eljárás feltölti a generálás módjára lehetőséget adó legördülő listát az opciókkal. Az \textbf{okBtnHandler()} kezeli az \textbf{Ok}-on történő kattintást. Itt történik meg a bemenet méretét tartalmazó mező ellenőrzése.\par Amennyiben megfelelő a hossz formátuma, azaz egy pozitív egész szám meghívódik a \textbf{generateNumbers()} eljárás. A \textbf{typeBox} változóban tárolt legördülőlista kiválasztott elemétől függően kerülnek a számok generálásra. A kigenerált tömböt átadja \textbf{SortingAlgorithm} osztályának, majd betölti a program főpaneljeit tartalmazó \textbf{BaseLayout.fxml} fájlt.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/RandomInputController.png}
	\caption{A RandomInputController osztálydiagramja}
\end{figure}
\paragraph{FileInputController osztály}
A \textbf{FileInputLayout.fxml} betöltésekor példányosul. Az \textbf{openChooser()} eljárás beállítja a formátumszűrőt(*.txt), valamint megjeleníti a fájltallózó párbeszédpanelt.\par A fájl kiválasztását követően meghívja a \textbf{loadFile()} függvényt.Kezdetben lekéri a fájl sorainak a számát a \textbf{getLineNumber()} eljárás segítségével, majd létrehoz egy ennek megfelelő nagyságú tömböt. Soronként végigolvassa a fájlt, amennyiben egy nem megfelelő sort talál(azaz egy sor üres vagy nem egy pozitív egész számot tartalmaz) befejezi a beolvasást, és hibaüzenetet jelenít meg.\par Amennyiben a beolvasás sikeres volt átadja a tömböt a \textbf{SortingAlgorithm} osztálynak, és megnyitja a főpaneleket tartalmazó \emph{FXML} fájlt.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/FileInputController.png}
	\caption{A FileInputController osztálydiagramja}
\end{figure}
\paragraph{BaseController osztály}
A \textbf{BaseLayout.fxml}-hez tartozó kontroller osztály. Az \textbf{initalize()} metódusa ellenőrzi a bemenet hosszát, amennyiben 100 elemnél több került megadásra a \textbf{tabPane} panelválasztóról leveszi a \textbf{Megfigyelés} lehetőséget.\par
 A további metódusai kezelik az eszköztár elemein való kattintást. A \textbf{handleExit()} eljárás a \textbf{Fájl -> Bezárás} kiválasztását követően fut le. A \textbf{MenuController}-hez hasonlóan a \textbf{handleAbout()} megjeleníti a program névjegyét.\par
 A \textbf{handleAlgorithm()} metódus lekéri a megjelenített panel listájából vagy táblázatából a kiválasztott algoritmust. Ezt az információt felhasználva a \textbf{InfoFlyWeightFactory} osztálytól elkéri a  rendezés leírását, majd létrehoz egy ablakot, amelyben megjeleníti az algoritmus jellemzését.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BaseController.png}
	\caption{A BaseController osztálydiagramja}
\end{figure}
\paragraph{OverviewController osztály}
Az \textbf{OverviewLayout.fxml} betöltésével példányosul. Az \textbf{initalize()} letiltja a \textbf{Léptetés} és \textbf{Lejátszás} gombokon való kattintást.\par
Az \textbf{animation} adattagja egy \textbf{TimeLine} típusú objektum, melynek segítségével definiálható egy a felületen végrehajtandó műveletsorozat. Jelen esetben az aktuális algoritmus \textbf{step()} műveletét ismétli amíg nem kerül megnyomásra a \textbf{Leállítás} gomb vagy nem fejeződött be a rendezés. \par
Az osztály további metódusai kezelik a panel gombjain történő kattintást, az \textbf{initBtns()} eljárás hozzárendel egy-egy eseménykezelőt a gombokhoz. A \textbf{checkButtons()} figyeli, hogy befejeződött-e már a rendezési feladat, amennyiben igen, akkor az \textbf{Újraindítás} gombot jeleníti meg.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/OverviewController.png}
	\caption{A OverviewController osztálydiagramja}
\end{figure}
\paragraph{OverviewListController osztály}
A \textbf{OverviewListLayout.fxml} fájl betöltésekor jön létre belőle egy példány. A \textbf{setList()} eljárás feltölti az \textbf{Összegzés} panelen látható listát a választható algoritmusok nevével. Az \textbf{initialize()} függvényben hozzárendelődik egy "figyelő" a listához. Amennyiben új érték kerül kiválasztásra a listában lefut a kiválasztott algoritmushoz tartozó \textbf{setDefaults()} metódus, továbbá betöltődik az \textbf{Állapotjelző} felület megfelelő elrendezése.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/OverviewListController.png}
	\caption{A OverviewListController osztálydiagramja}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/OverviewListController.png}
	\caption{A OverviewListController osztálydiagramja}
\end{figure}
\paragraph{OverviewChartController osztály}
A \textbf{OverviewChartLayout.fxml} kontroller osztálya. Feltölti az \textbf{Megfigyelés} panel diagramját a \textbf{SortingAlgorithm} által tárolt tömb értékeivel. Az osztályon keresztül módosíthatók az oszlopok színei, ehhez a \textbf{setColor(Node node, String color)} metódusát szükséges meghívni. A \textbf{getRandomColor()} eljárást a \textbf{Radix "előre"} algoritmus használja az edények kijelöléséhez. \par
A tervezéskor már kiderült, hogy a \emph{JavaFX} alapértelmezetten nem jeleníti meg az egyes oszlopok konkrét értékét. Így szükséges volt a \textbf{displayLegend(Data<String, Number> data)} eljárás létrehozása, amely egy oszlop felett elhelyez egy szövegdobozt, benne a pontos értékkel.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/OverviewChartController.png}
	\caption{A OverviewChartController osztálydiagramja}
\end{figure}
\paragraph{OverviewDoubleChartController osztály}
Az előbb ismertetett osztálynak két példányát tartalmazza. A \textbf{Radix "vissza"} algoritmus kiválasztásakor kerül betöltésre a hozzátartozó \emph{FXML} fájl, ekkor készül belőle egy objektum.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/OverviewDoubleChartController.png}
	\caption{A OverviewDoubleChartController osztálydiagramja}
\end{figure}
\paragraph{OverviewGraphController osztály}
Az algoritmus listából bináris fát használó eljárás kiválasztását követően példányosul. "Karbantartja" a \textbf{Állapotjelző felület} gráfját. Az \textbf{addVertices()} függvény hívását követően hozzáadja a panelhez a fát. Az oszlopdiagramját egy \textbf{OverviewChartController}-en keresztül lehet vezérelni.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/OverviewGraphController.png}
	\caption{A OverviewGraphController osztálydiagramja}
\end{figure}
\paragraph{SortingThreadListener interfész}
Az interfészt megvalósító osztály értesíthető egy programszál befejeződését követően a \textbf{notifyOfThreadComplete(final Thread thread)} eljáráson keresztül. A \textbf{BenchmarkController} valósítja meg. Ezáltal értesül róla, ha egy rendezési feladat befejeződött.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/SortingThreadListener.png}
	\caption{A SortingThreadListener interfészdiagramja}
\end{figure}
\paragraph{BenchmarkController osztály}
Az előbb bemutatott interfészt valósítja meg. A \textbf{sortingThreads} tömbben tárolja a futtatandó programszálak egy példányát. Valamint a \textbf{benchmarkDataList} által tárolt \textbf{BenchmarkData} objektumokban találhatóak meg az algoritmusok által végzett műveletek száma.\par
A \textbf{runSortingThreads()} eljárás a \textbf{sortingThreads} tömb minden elemére meghívja a \textbf{start()} függvényt, ezáltal elindulnak a programszálak.
Amennyiben egy rendezési eljárás befejeződött hozzáadja az \textbf{benchmarkDataList} listához a végzett műveletek számát, és értesíti az osztályt, hogy olvasson egy elemet a listából. A \textbf{notifyOfThreadComplete()} eljárás hozzáadja az új elemet a \textbf{BenchmarkTableController}-en keresztül a felület táblázatához.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BenchmarkController.png}
	\caption{A BenchmarkController osztálydiagramja}
\end{figure}
\paragraph{BenchmarkChartController osztály}
Egy listában tárolja azon elemeket, amelyekre már a felület táblázatán történt kattintás. Amennyiben olyan elem kerül kiválasztásra, amely még nem eleme a diagramnak hozzáadja a \textbf{addElement(BenchmarkData data)} metódus hívásával. Ebben a metódusban kerül ellenőrzésre, hogy már eleme-e a diagramnak az adott algoritmus. Amennyiben igen eltávolításra kerül.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/BenchmarkChartController.png}
	\caption{A BenchmarkChartController osztálydiagramja}
\end{figure}
A \textbf{OverviewTableController} és \textbf{BenchmarkTableController} osztályok nem kerültek bemutatásra, mivel egyetlen funkciójuk, hogy rajtuk keresztül érhetőek el a grafikus interfész táblázatai.
\subsubsection{Megjelenítési réteg osztályai}
A megjelenítésért felelős komponensek főként \emph{FXML} fájlokban kerülnek tárolásra. A gráf implementációja azonban ilyen módon nem készíthető el. Ezért került kialakításra a \textbf{view.graph} csomag. Röviden most e csomag osztályai kerülnek jellemzésre.
\paragraph{Vertex osztály}
A gráf egy csúcsát megvalósító osztály. Adattagja két \emph{JavaFX} komponens, egy címke(\textbf{Label}) és egy kör(\textbf{Circle}). Konstruktora megkapja a kör \textbf{X} és \textbf{Y} pozícióját az ablakon, továbbá opcionálisan a címke vagy szín értékét.\par
A \textbf{getGraphics()} metódus visszaadja a csúcs grafikus reprezentációját. A \textbf{setColor(String color)} metódus segítségével megváltoztatható a kör adattag színe.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/Vertex.png}
	\caption{A Vertex osztálydiagramja}
\end{figure}
\paragraph{Edge osztály}
Konstruktora a paraméterül kapott koordináták felhasználásával létrehoz egy vonal(\textbf{Line}) objektumot.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/Edge.png}
	\caption{Az Edge osztálydiagramja}
\end{figure}
\paragraph{Graph osztály}
Őse a \textbf{Group} osztály, ezáltal hozzáadható a felhasználó felülethez. Az \textbf{addVertex(Vertex vertex)} metódusával új csúcs adható hozzá a gráfhoz. A \textbf{bindVertexes(Vertex vertexA, Vertex vertexB)} eljárás a két paraméterül kapott csúcsot köti össze a \textbf{createEdge(Vertex vertexA, Vertex vertexB)} metódus segítségével.
\begin{figure}[H]
	\centering
	\includegraphics{pics/class/Graph.png}
	\caption{A Graph osztálydiagramja}
\end{figure}
\subsection{Tesztelés}
\subsubsection{Felhasználó felület tesztelése}
A felhasználó felület tesztelése manuálisan történik. A használati eseteket alapul véve a következő komponenseket szükséges tesztelni:
\paragraph{Főmenü eszköztára}
\textbf{Fájl -> Bezárás}ra kattintva a program futása leáll, az operációs rendszer \textbf{Feladatkezelő}jében sem fut tovább a \emph{JRE}.\par
\textbf{Segítség -> Névjegy}re kattintva megjelenik a szoftver leírása. Az \textbf{Ok} gombra kattintást követően bezárul az ablak, és a főmenü kerül előtérbe.
\paragraph{Főmenü gombjai}
Az egyes gombokra kattintva megjelennek a bemenet megadására alkalmas panelek.
\paragraph{Számok manuális megadása panel}
Csúszka ellenőrzése, amikor nem férnek ki a beviteli mezők.\par
Kezdetben nem kattintható egyik gomb sem. A \textbf{"Méret:"} mezőt kitöltve például az \textbf{almafa} szöveggel vagy 0 értékkel, majd leütve az \textbf{ENTER} billentyűt továbbra sem kattinthatóak a gombok.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{pics/test/manual_almafa0.jpg}
	\caption{Nem pozitív egész szám megadása}
\end{figure}
Megfelelő elemhossz megadása után, majd átírva nem megfelelőre ismét inaktívvá válnak a gombok.\par
A sikeres hossz és rendezendő értékek megadását követően megjelenik a program főpanelje.
\paragraph{Számok generálása panel}
Legördülő lista elemeinek az ellenőrzése.\par
Amennyiben csak a méret került megadásra, és még nincs kiválasztott generálási mód az \textbf{Ok} gomb nem kattintható. Amennyiben a módszer kiválasztásra került, de a méret nem megfelelő vagy nincs kitöltve az \textbf{Ok}-ra történő kattintásnak nincs hatása, továbbra is a panel látszik.
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{pics/test/generate_notselectedalmafa.jpg}
	\caption{Nem pozitív egész szám és módszer megadása}
\end{figure}
A sikeres méret és generálási módszer megadását követően megjelenik a program főpanelje.
\paragraph{Fájl betöltése párbeszédablak}
Fájlkiterjesztés szűrő ellenőrzése, csak a "\textbf{Szöveges fájl (*.txt)}" opciót tartalmazhatja, ennek megfelelően a tallózóban csak az ilyen kiterjesztésű fájlok láthatók.
\begin{figure}[H]
	\centering
	\includegraphics{pics/test/fileextension.png}
	\caption{Fájlkiterjesztés legördülő lista}
\end{figure}
Nem megfelelő fájl megadását követően hibaüzenetet jelenít meg a program. Ilyen "hibás" fájlokat találunk a \textbf{resources\textbackslash input} könyvtárban:
\begin{description}
	\item[$\bullet$] üres fájl (input\textunderscore empty.txt)
	\item[$\bullet$] a fájl egy karaktersorozatot tartalmaz (input\textunderscore almafa.txt)
	\item[$\bullet$] pozitív egész számok az elemei, de van üres sora (input\textunderscore oneemptyline.txt)
\end{description}\par
Megfelelő fájl tallózásakor (például: input\textunderscore ok) megjelenik a főpanel.
\paragraph{Főpanel eszköztára}
Szintén elvégezendők a \textbf{Főmenü eszköztár}nál leírt tesztek, annyi különbséggel, hogy a \textbf{Névjegy} bezárást követően a főpanelt kell látnunk.\par
Továbbá tesztelendő funkció a \textbf{Segítség -> Az algoritmusról} menüpont. A \textbf{Megfigyelés} panel az aktív, és a listában nincs kiválasztott elem, akkor hibaüzenet jelenik meg. Ugyanez érvényes arra az esetre, ha a \textbf{Összehasonlítás} panel táblázatában nincs kiválasztott sor. Egy elem (például: "Kupacrendezés") kiválasztását követően megjelenik az algoritmus leírása, majd az \textbf{Ok} gombra kattintva bezárul az ablak, és a főpanel látható.\par
További funkció a \textbf{Fájl -> Vissza a főmenübe} lehetőség, ezt kiválasztva a főmenü jelenik meg.
\paragraph{Megfigyelés panel}
A \textbf{Léptetés} és \textbf{Lejátszás} gombok inaktívak amíg nincs kiválasztott algoritmus. Például a "Gyorsrendezés"t kiválasztva már aktívak. A \textbf{Lejátszás}ra kattintva a gomb szövege \textbf{Megállításra} változik. A rendezés befejeződését követően az \textbf{Újraindítás} gomb látható. 
\par A \textbf{Léptetés} gombra kattintva egy következő állapot látható az \textbf{Állapotjelző} felületen. Ha egy elemű a bemenet, és például a buborékrendezés van kiválasztva, akkor a gombon történő kattintást követően az \textbf{Újraindítás} gomb jelenik meg.
\par Több elem nem jelölhető ki egyszerre az algoritmus listában.
\paragraph{Összehasonlítás panel}
A "Buborékrendezés" sorára kattintva hozzáadódik a diagramhoz az összehasonlítások és mozgatások összege. Ismételt dupla kattintást követően pedig eltűnik ez az információ.\par
Az oszlopok szélessége állítható, így szükséges tesztelni a táblázat alján lévő csúszkát.
\subsubsection{Egységtesztelés}
Az algoritmusok és műveletszámuk helyességének ellenőrzéséhez egységtesztek készültek. Ezáltal nem feltétlenül szükséges fehérdoboz megközelítéssel ellenőrizni a rendezési eljárásokat.\par
 Mivel az \textbf{algorithm} csomagban található eljárások nagy része megegyezik a \textbf{algorithm.raw} csomag algoritmusaival, ezért célszerűbb az utóbbi osztályaihoz teszteket készíteni, egyszerűbb felépítésük és kisebb mértékű függőségük miatt. \par
 Az \textbf{algortihm.raw.test} tartalmazza az egységtesztosztályokat. Felépítésüket tekintve azonosak, mindegyikben öt eset kerül ellenőrzésre. A tesztelést végző metódusok, azaz a tesztesetek a következők:
 \paragraph{zeroElement()}
Üres tömböt ad át rendezésre. Ekkor a rendezés után ellenőrzi, hogy szintén egy üres tömböt kapott-e vissza valamint, hogy a műveletek száma nulla-e.
\paragraph{oneElement()}
A 42 értékkel hívja meg a rendezési eljárásokat. Ezt követően ellenőrzi, hogy ugyanezt az egy elemet tartalmazó tömböt kapta-e vissza a rendezést követően, valamint, hogy a műveletjelző értékek nullák-e.
\paragraph{fiveConcretElement()}
A  $[42, 20, 7, 18, 100]$ tömbön indítja el a rendezéseket. A rendezés befejeztével meghívja a \emph{Java} beépített rendező algoritmusát(\textbf{Arrays.sort}), és ellenőrzi, hogy a rendezés befejeztekor tárolt tömb azonos-e az előbb említett függvényhívás eredményével. Továbbá ellenőrzi az algoritmus által végzett műveletek összegét.
\paragraph{thousandRandomElement()}
Száz véletlen választott értéken hívja meg a rendezéseket. A műveletek száma nem kerül ellenőrzésre, csak az előbb említett módon a tömb tartalma.
\paragraph{millionRandomElement}
Az előző eljárással azonos, mindössze a tömb mérete különbözik. Ez feleltethető meg a "nagy" bemenetre történő ellenőrzésnek, mivel csak ezek a rendezések hívódnak meg száz elemnél hosszabb bemenet megadásakor.
\subsubsection{Strukturális tesztelés}
Fehérdoboz tesztnek vetjük alá a programot, mely során vizsgáljuk, hogy a lehetséges futási út során a megfelelő eredményeket produkálja-e a szoftver.\par
Miután elindult a program válasszuk a \textbf{Fájl}ból betöltés lehetőséget. Adjuk meg a megjelenő fájltallózóban a \textbf{resources\textbackslash input} könyvtárban található \textbf{input\textunderscore ok.txt} fájlt.
\begin{figure}[H]
	\centering
	\includegraphics{pics/test/file_content.png}
	\caption{A strukturális teszthez használt fájl tartalma}
\end{figure}
A betöltést követően megjelenik a program főpanelje. Látható, hogy a \textbf{Megfigyelés} panel az alapértelmezett, mivel a bemenet kevesebb, mint száz elemet tartalmaz. A legtöbb algoritmus lejátszására már nincs szükség, mivel működésük a \textbf{Egységtesztelés} során már ellenőrzésre került. Azonban a radix rendezések mivel nem jelennek meg a \textbf{Összegzés} panelen így ellenőrizendők.\par
Válasszuk ki az algoritmus listából a \textbf{Radix "előre"} rendezést. Ekkor az oszlopok felett az értékek binárisan vannak ábrázolva. A \textbf{Lejátszás} gombra kattintást követően várjuk ki, amíg befejeződik a rendezés. Ekkor látható, hogy az összes oszlop színe \textcolor{done}{\Huge$\bullet$} és megjelent a \textbf{Újraindítás} gomb. Az \textbf{Állapotjelző táblázat}ban pedig a következő értékek szerepelnek:
\begin{figure}[H]
	\centering
	\includegraphics{pics/test/radixforwardcounters.png}
	\caption{Radix "előre" rendezést követően az állapotjelzők}
\end{figure}
Amint látható a rendezésnek nem volt szüksége az összes bitet megvizsgálni, mivel 14 elemvizsgálatot követően már minden edény hossza egy volt. 
\par
Most ellenőrizzük a \textbf{Radix "vissza"} algoritmus helyességét. A listából kiválasztva megjelenik két oszlopdiagram egymás felett. A felső diagram tartalmazza a rendezendő értékeket. A \textbf{Lejátszás}ra kattintva megfigyelhetjük, hogy hogyan történik az értékek átmásolása egyik "tömbből" a másikba. A rendezés befejeztével a felső diagramon szerepelnek az értékek növekvő sorrendben, ekkor minden oszlop \textcolor{done}{\Huge$\bullet$} színű és látható a \textbf{Újraindítás} gomb. Az \textbf{Állapotjelző táblázat} értékei a következők:
\begin{figure}[H]
	\centering
	\includegraphics{pics/test/radixbackwardcounters.png}
	\caption{Radix "vissza" rendezést követően az állapotjelzők}
\end{figure}
A vizsgálatok száma azonos a bitek számának és a tömb méretének szorzatával, azaz $7\cdot 5 = 35$. Az aktuális bitet jelző szám a rendezés befejeztével nyilván 1.\par
Kérjük le a \textbf{Radix "vissza"} rendezés leírását az eszköztár \textbf{Segítség -> Az algoritmusról} pontján való kattintással, majd zárjuk be. Ekkor továbbra is a \textbf{Megfigyelés} panelt kell látnunk a befejeződött rendezési feladattal.\par
Navigáljunk át a \textbf{Összehasonlítás} panelre. Láthatjuk a kitöltött \textbf{Összegzés táblázat}ot, valamint az üres diagramot. Adjuk hozzá a \textbf{Gyorsrendezés}t és \textbf{Buborékrendezés}t a diagramhoz, azaz kattintsunk kétszer ezeken a sorokon. Ekkor a következőt látjuk:
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{pics/test/benchmark.png}
	\caption{\textbf{Összegzés} panel}
\end{figure}
Ismételten kattintva a \textbf{Gyorsrendezés}en eltűnik a hozzá tartozó oszlop, már csak a \textbf{Buborékrendezés} műveletszáma látható a diagramon.\par
Válasszuk ki az eszköztár \textbf{Segítség} menüjének \textbf{Névjegy} menüpontját, aminek a hatására azonnal látható lesz a program névjegye. Zárjuk be a névjegyet, majd a \textbf{Fájl} menü \textbf{Bezárás} menüpontjával állítsuk le a szoftver futását.
\chapter{Összegzés}
Remélem, hogy a dolgozat segítséget nyújt azoknak, akiket érdekelnek a rendezési algoritmusok. Próbáltam az eljárásokat a lehető legszemléletesebben bemutatni, úgy, hogy az befogadható legyen a hallgatók számára és elősegítse tanulmányaikat.\par
Az alkalmazás fejlesztése során sokat tanultam. Mélyrehatóbban megismertem a program által bemutatott algoritmusokat, sikeresen használtam néhány programtervezési mintát. Továbbá többet megtudtam a \emph{Java} nyelv eszközeiről, valamint technológiai szempontból talán a legjelentősebb, hogy megismertem a \emph{JavaFX} platformot és felépítését.\par
\hiddensubsubsection{A szoftver továbbfejlesztése}
A program a rendezési algoritmusok közül csak néhányat szemléltet, így ésszerű cél további eljárások implementálása. Mivel nagyjából minden rendezési algoritmus által használt adatstruktúra már adott, így egyetlen feladat ezen eljárások létrehozása és "bedrótozása".\par
Továbbá elegánsabb megoldás lenne, ha minden algoritmushoz csak egy implementáció tartozna, ez azonban ahogy a tervezés során kiderült nem igazán megvalósítható a \textbf{JavaFX} szálkezeléséből adódóan. Ez a fejlesztés még inkább csökkentené a kód redundanciáját.
\\
\\
\par
Végszóként szeretném megköszönni Veszprémi Anna tanárnőnek, hogy elvállalta a projekt témavezetői szerepét és támogatott a dolgozat elkészítése során.

\begin{thebibliography}{widest entry}
\bibitem{Fekete}
Dr. Fekete István:
\emph{Algoritmusok és adatszerkezetek I. jegyzet},
[ONLINE] [Hivatkozva: 2015.04.20] \url{http://people.inf.elte.hu/fekete/algoritmusok_bsc/alg_1_jegyzet/}
\bibitem{Cormen}
Thomas H. Cormen - Charles E. Leiserson - Ronald L. Rivest - Clifford Stein:
\emph{Új algoritmusok},
Scolar kiadó, 2003,
[992], 9789639193901
\bibitem{Ronyai}
Rónyai Lajos - Ivanyos Gábor - Szabó Réka:
\emph{Algoritmusok},
Typotex Elektronikus Kiadó Kft., 2000,
[350], 9789632790145
\bibitem{Demuth}
Demuth, H.:
\emph{Electronic Data Sorting},
PhD thesis, Stanford University,
1956, [184]
\bibitem{ShellWiki}
\emph{Shellsort},
Wikipedia the free encyclopedia.
[ONLINE] [Hivatkozva: 2015.04.25]
\url{http://en.wikipedia.org/wiki/Shellsort/}
\bibitem{Pratt}
Vaughan Ronald Pratt:
\emph{Shellsort and Sorting Networks (Outstanding Dissertations in the Computer Sciences)}
Dissertations-G, 1980,
[59], 0824044061
\bibitem{Horae}
C.A.R. Hoare:
\emph{Algorithm 64: Quicksort}
Communications of the ACM, 4, 7, 1961
\bibitem{Java}
\emph{Java (programming language)},
Wikipedia the free encyclopedia.
[ONLINE] [Hivatkozva: 2015.04.21]
\url{http://en.wikipedia.org/wiki/Java_(programming_language)/}
\bibitem{JavaFX}
\emph{JavaFX},
Wikipedia the free encyclopedia.
[ONLINE] [Hivatkozva: 2015.04.21]
\url{http://en.wikipedia.org/wiki/JavaFX/}
\bibitem{JUnit}
\emph{JUnit},
Wikipedia the free encyclopedia.
[ONLINE] [Hivatkozva: 2015.05.01]
\url{http://en.wikipedia.org/wiki/JUnit}
\bibitem{FXML}
\emph{FXML},
Wikipedia the free encyclopedia.
[ONLINE] [Hivatkozva: 2015.05.10]
\url{http://en.wikipedia.org/wiki/FXML/}
\bibitem{Survey}
The Takipi Blog:
\emph{We Analyzed 30,000 GitHub Projects – Here Are The Top 100 Libraries in Java, JS and Ruby},
[ONLINE] [Hivatkozva: 2015.04.30] \url{http://blog.takipi.com/we-analyzed-30000-github-projects-here-are-the-top-100}
\url{-libraries-in-java-js-and-ruby/}
\end{thebibliography}

\end{document}
